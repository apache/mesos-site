<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: process::ProcessBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceprocess.html">process</a></li><li class="navelem"><a class="el" href="classprocess_1_1ProcessBase.html">ProcessBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classprocess_1_1ProcessBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">process::ProcessBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="libprocess_2include_2process_2process_8hpp_source.html">process.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for process::ProcessBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classprocess_1_1ProcessBase.png" usemap="#process::ProcessBase_map" alt=""/>
  <map id="process::ProcessBase_map" name="process::ProcessBase_map">
<area href="structprocess_1_1EventConsumer.html" alt="process::EventConsumer" shape="rect" coords="0,0,543,24"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; T &gt;" shape="rect" coords="553,112,1096,136"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; AwaitProcess&lt; T &gt; &gt;" shape="rect" coords="553,168,1096,192"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; CheckerProcess &gt;" shape="rect" coords="553,224,1096,248"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; CollectProcess&lt; T &gt; &gt;" shape="rect" coords="553,280,1096,304"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ContainerDaemonProcess &gt;" shape="rect" coords="553,336,1096,360"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; DockerContainerizerProcess &gt;" shape="rect" coords="553,392,1096,416"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; FetcherProcess &gt;" shape="rect" coords="553,448,1096,472"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; GarbageCollectorProcess &gt;" shape="rect" coords="553,504,1096,528"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; GroupProcess &gt;" shape="rect" coords="553,560,1096,584"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Heartbeater&lt; Message, Event &gt; &gt;" shape="rect" coords="553,616,1096,640"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Help &gt;" shape="rect" coords="553,672,1096,696"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; HttpConnectionProcess&lt; Call, Event &gt; &gt;" shape="rect" coords="553,728,1096,752"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; HttpProxy &gt;" shape="rect" coords="553,784,1096,808"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; JobObjectManager &gt;" shape="rect" coords="553,840,1096,864"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Logging &gt;" shape="rect" coords="553,896,1096,920"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogProcess &gt;" shape="rect" coords="553,952,1096,976"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogReaderProcess &gt;" shape="rect" coords="553,1008,1096,1032"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogWriterProcess &gt;" shape="rect" coords="553,1064,1096,1088"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Master &gt;" shape="rect" coords="553,1120,1096,1144"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MemoryProfiler &gt;" shape="rect" coords="553,1176,1096,1200"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosAllocatorProcess &gt;" shape="rect" coords="553,1232,1096,1256"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosContainerizerProcess &gt;" shape="rect" coords="553,1288,1096,1312"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosIsolatorProcess &gt;" shape="rect" coords="553,1344,1096,1368"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MetricsProcess &gt;" shape="rect" coords="553,1400,1096,1424"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; NetworkProcess &gt;" shape="rect" coords="553,1456,1096,1480"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Profiler &gt;" shape="rect" coords="553,1512,1096,1536"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ProvisionerProcess &gt;" shape="rect" coords="553,1568,1096,1592"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; RateLimiterProcess &gt;" shape="rect" coords="553,1624,1096,1648"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReaderProcess&lt; T &gt; &gt;" shape="rect" coords="553,1680,1096,1704"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReaperProcess &gt;" shape="rect" coords="553,1736,1096,1760"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReqResProcess&lt; Req, Res &gt; &gt;" shape="rect" coords="553,1792,1096,1816"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; SequenceProcess &gt;" shape="rect" coords="553,1848,1096,1872"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Slave &gt;" shape="rect" coords="553,1904,1096,1928"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; StatusUpdateManagerProcess&lt; IDType, CheckpointType, UpdateType &gt; &gt;" shape="rect" coords="553,1960,1096,1984"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Subsystem &gt;" shape="rect" coords="553,2016,1096,2040"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; System &gt;" shape="rect" coords="553,2072,1096,2096"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ThunkProcess&lt; R &gt; &gt;" shape="rect" coords="553,2128,1096,2152"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; UriDiskProfileAdaptorProcess &gt;" shape="rect" coords="553,2184,1096,2208"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; VersionProcess &gt;" shape="rect" coords="553,2240,1096,2264"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; WhitelistWatcher &gt;" shape="rect" coords="553,2296,1096,2320"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a318038bacd95e4260864533f7cfe12fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a318038bacd95e4260864533f7cfe12fd">ProcessBase</a> (const std::string &amp;id=&quot;&quot;)</td></tr>
<tr class="separator:a318038bacd95e4260864533f7cfe12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6c6b8f5aff506a97ce6c4f91a29d3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a20b6c6b8f5aff506a97ce6c4f91a29d3">~ProcessBase</a> ()</td></tr>
<tr class="separator:a20b6c6b8f5aff506a97ce6c4f91a29d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff87364baa79991901b8d73dc5c5fca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a7ff87364baa79991901b8d73dc5c5fca">self</a> () const </td></tr>
<tr class="separator:a7ff87364baa79991901b8d73dc5c5fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structprocess_1_1EventConsumer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structprocess_1_1EventConsumer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structprocess_1_1EventConsumer.html">process::EventConsumer</a></td></tr>
<tr class="memitem:a9b310e99e6cef77273fd1cc403c871b1 inherit pub_methods_structprocess_1_1EventConsumer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocess_1_1EventConsumer.html#a9b310e99e6cef77273fd1cc403c871b1">~EventConsumer</a> ()</td></tr>
<tr class="separator:a9b310e99e6cef77273fd1cc403c871b1 inherit pub_methods_structprocess_1_1EventConsumer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a39f8e327dc132dd4a3a95fee650458f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a> { <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a>, 
<a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a435d743b35551ea7106af41c4a308c01">RemoteConnection::RECONNECT</a>
 }<tr class="memdesc:a39f8e327dc132dd4a3a95fee650458f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of the <code>link</code> call when the target <code>pid</code> points to a remote process.  <a href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a39f8e327dc132dd4a3a95fee650458f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ca53e513d7ead18e05466c60e51891"><td class="memItemLeft" align="right" valign="top">typedef lambda::function&lt; void(const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a></td></tr>
<tr class="memdesc:ab7ca53e513d7ead18e05466c60e51891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a "from" <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code> and a message body as arguments.  <a href="#ab7ca53e513d7ead18e05466c60e51891">More...</a><br /></td></tr>
<tr class="separator:ab7ca53e513d7ead18e05466c60e51891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d8346a62ad423899f6f9e9ee08806"><td class="memItemLeft" align="right" valign="top">typedef lambda::function&lt; <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a></td></tr>
<tr class="memdesc:a083d8346a62ad423899f6f9e9ee08806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>.  <a href="#a083d8346a62ad423899f6f9e9ee08806">More...</a><br /></td></tr>
<tr class="separator:a083d8346a62ad423899f6f9e9ee08806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834b08377ce20a01893a033c46898f6"><td class="memItemLeft" align="right" valign="top">typedef lambda::function&lt; <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt; const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a></td></tr>
<tr class="memdesc:a0834b08377ce20a01893a033c46898f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and an <code><a class="el" href="classOption.html">Option</a>&lt;Principal&gt;</code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>.  <a href="#a0834b08377ce20a01893a033c46898f6">More...</a><br /></td></tr>
<tr class="separator:a0834b08377ce20a01893a033c46898f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2accda04cb99a8337c501958ff85ce01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a2accda04cb99a8337c501958ff85ce01">serve</a> (<a class="el" href="structprocess_1_1Event.html">Event</a> &amp;&amp;event)</td></tr>
<tr class="memdesc:a2accda04cb99a8337c501958ff85ce01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when an event is serviced.  <a href="#a2accda04cb99a8337c501958ff85ce01">More...</a><br /></td></tr>
<tr class="separator:a2accda04cb99a8337c501958ff85ce01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab442a83e7b73449ad9237af4ad02a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#aab442a83e7b73449ad9237af4ad02a80">consume</a> (<a class="el" href="structprocess_1_1MessageEvent.html">MessageEvent</a> &amp;&amp;event) override</td></tr>
<tr class="separator:aab442a83e7b73449ad9237af4ad02a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d4ca7d97e0a296121deac831ac1917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ad9d4ca7d97e0a296121deac831ac1917">consume</a> (<a class="el" href="structprocess_1_1DispatchEvent.html">DispatchEvent</a> &amp;&amp;event) override</td></tr>
<tr class="separator:ad9d4ca7d97e0a296121deac831ac1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f2b9a57194ffdbe873a318337e0f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a37f2b9a57194ffdbe873a318337e0f76">consume</a> (<a class="el" href="structprocess_1_1HttpEvent.html">HttpEvent</a> &amp;&amp;event) override</td></tr>
<tr class="separator:a37f2b9a57194ffdbe873a318337e0f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a583eaf601e28e41073181ec3ebbc32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a9a583eaf601e28e41073181ec3ebbc32">consume</a> (<a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a> &amp;&amp;event) override</td></tr>
<tr class="separator:a9a583eaf601e28e41073181ec3ebbc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3058269bffe1b73cb8a4469a66542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a4dd3058269bffe1b73cb8a4469a66542">consume</a> (<a class="el" href="structprocess_1_1TerminateEvent.html">TerminateEvent</a> &amp;&amp;event) override</td></tr>
<tr class="separator:a4dd3058269bffe1b73cb8a4469a66542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf49d6234eb638d068a98514e4ae3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a6baf49d6234eb638d068a98514e4ae3f">initialize</a> ()</td></tr>
<tr class="memdesc:a6baf49d6234eb638d068a98514e4ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a process gets spawned.  <a href="#a6baf49d6234eb638d068a98514e4ae3f">More...</a><br /></td></tr>
<tr class="separator:a6baf49d6234eb638d068a98514e4ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ac3fd4eededbb6015c305e12411b98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a07ac3fd4eededbb6015c305e12411b98">finalize</a> ()</td></tr>
<tr class="memdesc:a07ac3fd4eededbb6015c305e12411b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a process is terminated.  <a href="#a07ac3fd4eededbb6015c305e12411b98">More...</a><br /></td></tr>
<tr class="separator:a07ac3fd4eededbb6015c305e12411b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0053b515e25f366a29a6897467bebc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0a0053b515e25f366a29a6897467bebc">exited</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;)</td></tr>
<tr class="memdesc:a0a0053b515e25f366a29a6897467bebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a linked process has exited.  <a href="#a0a0053b515e25f366a29a6897467bebc">More...</a><br /></td></tr>
<tr class="separator:a0a0053b515e25f366a29a6897467bebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a4b602aa7e2656a647323da1bacf50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a38a4b602aa7e2656a647323da1bacf50">lost</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;)</td></tr>
<tr class="memdesc:a38a4b602aa7e2656a647323da1bacf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a linked process can no longer be monitored.  <a href="#a38a4b602aa7e2656a647323da1bacf50">More...</a><br /></td></tr>
<tr class="separator:a38a4b602aa7e2656a647323da1bacf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d581940120abfb787e46568e7a3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#af90d581940120abfb787e46568e7a3af">send</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;to, const std::string &amp;name, const char *data=nullptr, size_t length=0)</td></tr>
<tr class="memdesc:af90d581940120abfb787e46568e7a3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the message to the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#af90d581940120abfb787e46568e7a3af">More...</a><br /></td></tr>
<tr class="separator:af90d581940120abfb787e46568e7a3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72621d5c290fc558dcffb62b7d05635b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a72621d5c290fc558dcffb62b7d05635b">send</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;to, std::string &amp;&amp;name)</td></tr>
<tr class="separator:a72621d5c290fc558dcffb62b7d05635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d5a19d749f9f140b5ede6800549a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ab60d5a19d749f9f140b5ede6800549a6">send</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;to, std::string &amp;&amp;name, std::string &amp;&amp;data)</td></tr>
<tr class="separator:ab60d5a19d749f9f140b5ede6800549a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97b59a857843096aa219d0209837c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess_1_1UPID.html">UPID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42">link</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;pid, const <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a> remote=<a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a>)</td></tr>
<tr class="memdesc:ae97b59a857843096aa219d0209837c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links with the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#ae97b59a857843096aa219d0209837c42">More...</a><br /></td></tr>
<tr class="separator:ae97b59a857843096aa219d0209837c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591501723f8320f0b29e2a7c64a501eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a591501723f8320f0b29e2a7c64a501eb">install</a> (const std::string &amp;name, const <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a591501723f8320f0b29e2a7c64a501eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for messages with the specified name.  <a href="#a591501723f8320f0b29e2a7c64a501eb">More...</a><br /></td></tr>
<tr class="separator:a591501723f8320f0b29e2a7c64a501eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfef5689de05716f582fa737f165133"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dfef5689de05716f582fa737f165133"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a8dfef5689de05716f582fa737f165133">install</a> (const std::string &amp;name, void(T::*method)(const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;))</td></tr>
<tr class="memdesc:a8dfef5689de05716f582fa737f165133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for messages with the specified name.  <a href="#a8dfef5689de05716f582fa737f165133">More...</a><br /></td></tr>
<tr class="separator:a8dfef5689de05716f582fa737f165133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685d23d0dc0f42a0038dda0724e5d783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a685d23d0dc0f42a0038dda0724e5d783">delegate</a> (const std::string &amp;name, const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;pid)</td></tr>
<tr class="memdesc:a685d23d0dc0f42a0038dda0724e5d783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates incoming messages, with the specified name, to the <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#a685d23d0dc0f42a0038dda0724e5d783">More...</a><br /></td></tr>
<tr class="separator:a685d23d0dc0f42a0038dda0724e5d783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5">route</a> (const std::string &amp;name, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, const <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a> &amp;handler, const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for HTTP requests with the specified name.  <a href="#af0d1a6f8da798dfb2b6ea92550b8c6f5">More...</a><br /></td></tr>
<tr class="separator:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff038897726b5ff2713e5d5602efa6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70ff038897726b5ff2713e5d5602efa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a70ff038897726b5ff2713e5d5602efa6">route</a> (const std::string &amp;name, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*method)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;), const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:a70ff038897726b5ff2713e5d5602efa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for HTTP requests with the specified name.  <a href="#a70ff038897726b5ff2713e5d5602efa6">More...</a><br /></td></tr>
<tr class="separator:a70ff038897726b5ff2713e5d5602efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb721f72a1b9b517808149010de8b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0bb721f72a1b9b517808149010de8b9a">route</a> (const std::string &amp;name, const std::string &amp;realm, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, const <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a> &amp;handler, const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="separator:a0bb721f72a1b9b517808149010de8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf86bbf94884960c041e081a34bee4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cf86bbf94884960c041e081a34bee4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a37cf86bbf94884960c041e081a34bee4">route</a> (const std::string &amp;name, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;realm, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*method)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;), const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:a37cf86bbf94884960c041e081a34bee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards to the correct overload of <code><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route()</a></code>, depending on whether the authentication realm <code>realm</code> is present.  <a href="#a37cf86bbf94884960c041e081a34bee4">More...</a><br /></td></tr>
<tr class="separator:a37cf86bbf94884960c041e081a34bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b32f94df3a92225825a1cc426b060c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a6b32f94df3a92225825a1cc426b060c8">provide</a> (const std::string &amp;name, const std::string &amp;path, const std::map&lt; std::string, std::string &gt; &amp;types=<a class="el" href="namespaceprocess_1_1mime.html#aa12bd84b9c99ba313fbbf8c56bc411cb">mime::types</a>)</td></tr>
<tr class="memdesc:a6b32f94df3a92225825a1cc426b060c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the default HTTP request handler to provide the static asset(s) at the specified <em>absolute</em> path for the specified name.  <a href="#a6b32f94df3a92225825a1cc426b060c8">More...</a><br /></td></tr>
<tr class="separator:a6b32f94df3a92225825a1cc426b060c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641dc674baabe6a58e4f4869090bd310"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a641dc674baabe6a58e4f4869090bd310"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a641dc674baabe6a58e4f4869090bd310">eventCount</a> ()</td></tr>
<tr class="memdesc:a641dc674baabe6a58e4f4869090bd310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of events of the given type currently on the event queue.  <a href="#a641dc674baabe6a58e4f4869090bd310">More...</a><br /></td></tr>
<tr class="separator:a641dc674baabe6a58e4f4869090bd310"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a43e117b196c850619d5255046edb3e79"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a43e117b196c850619d5255046edb3e79">SocketManager</a></td></tr>
<tr class="separator:a43e117b196c850619d5255046edb3e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1701c7594fe2cf1c96b951a52eb0396"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ae1701c7594fe2cf1c96b951a52eb0396">ProcessManager</a></td></tr>
<tr class="separator:ae1701c7594fe2cf1c96b951a52eb0396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2e3480d3fd92960e1addaf8cc71d6b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#adf2e3480d3fd92960e1addaf8cc71d6b">schedule</a> (void *)</td></tr>
<tr class="separator:adf2e3480d3fd92960e1addaf8cc71d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0834b08377ce20a01893a033c46898f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;<a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a>&gt; const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp;, const <a class="el" href="classOption.html">Option</a>&lt;<a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a>&gt;&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">process::ProcessBase::AuthenticatedHttpRequestHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and an <code><a class="el" href="classOption.html">Option</a>&lt;Principal&gt;</code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>. </p>
<p>This type is meant to be used for the endpoint handlers of authenticated HTTP endpoints.</p>
<p>If the handler is called and the principal is set, this implies two things: 1) The realm that the handler's endpoint is installed into requires authentication. 2) The HTTP request has been successfully authenticated.</p>
<p>If the principal is not set, then the endpoint's realm does not require authentication.</p>
<p>The default consume implementation for HTTP events invokes installed HTTP handlers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a083d8346a62ad423899f6f9e9ee08806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;<a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a>&gt;const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">process::ProcessBase::HttpRequestHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>. </p>
<p>The default consume implementation for HTTP events invokes installed HTTP handlers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7ca53e513d7ead18e05466c60e51891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;void(const <a class="el" href="structprocess_1_1UPID.html">UPID</a>&amp;, const std::string&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">process::ProcessBase::MessageHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a "from" <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code> and a message body as arguments. </p>
<p>The default consume implementation for message events invokes installed message handlers, or delegates the message to another process. A message handler always takes precedence over delegating.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#a591501723f8320f0b29e2a7c64a501eb" title="Sets up a handler for messages with the specified name. ">process::ProcessBase::install</a> </dd>
<dd>
<a class="el" href="classprocess_1_1ProcessBase.html#a685d23d0dc0f42a0038dda0724e5d783" title="Delegates incoming messages, with the specified name, to the UPID. ">process::ProcessBase::delegate</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">process::ProcessBase::RemoteConnection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the behavior of the <code>link</code> call when the target <code>pid</code> points to a remote process. </p>
<p>This enum has no effect if the target <code>pid</code> points to a local process. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e"></a>REUSE&#160;</td><td class="fielddoc">
<p>If a persistent socket to the target <code>pid</code> does not exist, a new link is created. </p>
<p>If a persistent socket already exists, <code>link</code> will subscribe this process to the existing link.</p>
<p>This is the default behavior. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8a435d743b35551ea7106af41c4a308c01"></a>RECONNECT&#160;</td><td class="fielddoc">
<p>If a persistent socket to the target <code>pid</code> does not exist, a new link is created. </p>
<p>If a persistent socket already exists, <code>link</code> create a new socket connection with the target <code>pid</code> and <em>atomically</em> swap the existing link with the new link.</p>
<p>Existing linkers will remain linked, albeit via the new socket. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a318038bacd95e4260864533f7cfe12fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">process::ProcessBase::ProcessBase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20b6c6b8f5aff506a97ce6c4f91a29d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual process::ProcessBase::~ProcessBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aab442a83e7b73449ad9237af4ad02a80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1MessageEvent.html">MessageEvent</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventConsumer.html#a711e0aecfcdbe69216e26a630d52869d">process::EventConsumer</a>.</p>

<p>Reimplemented in <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; T &gt;</a>, <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; Slave &gt;</a>, <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; NetworkProcess &gt;</a>, <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; Master &gt;</a>, <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; StatusUpdateManagerProcess&lt; IDType, CheckpointType, UpdateType &gt; &gt;</a>, <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; CheckerProcess &gt;</a>, and <a class="el" href="classProtobufProcess.html#a5c6659fa98d4c54ae10ced56690f08ee">ProtobufProcess&lt; ReqResProcess&lt; Req, Res &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad9d4ca7d97e0a296121deac831ac1917"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1DispatchEvent.html">DispatchEvent</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventConsumer.html#a3314724fb3b29d6f8093b0ba9d182f18">process::EventConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a37f2b9a57194ffdbe873a318337e0f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1HttpEvent.html">HttpEvent</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventConsumer.html#aa99c69fa7be738755110daac37570424">process::EventConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a9a583eaf601e28e41073181ec3ebbc32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventConsumer.html#ad53e08d44e0ee73adea71dd443b1802c">process::EventConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd3058269bffe1b73cb8a4469a66542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1TerminateEvent.html">TerminateEvent</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventConsumer.html#ad0f7d6f28720779ce999cd6bf8869313">process::EventConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a685d23d0dc0f42a0038dda0724e5d783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::delegate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delegates incoming messages, with the specified name, to the <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>

</div>
</div>
<a class="anchor" id="a641dc674baabe6a58e4f4869090bd310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t process::ProcessBase::eventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of events of the given type currently on the event queue. </p>
<p>MUST be invoked from within the process itself in order to safely examine events. </p>

</div>
</div>
<a class="anchor" id="a0a0053b515e25f366a29a6897467bebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::exited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a linked process has exited. </p>
<p>For local linked processes (i.e., when the linker and linkee are part of the same OS process), this can be used to reliably detect when the linked process has exited.</p>
<p>For remote linked processes, this indicates that the persistent TCP connection between the linker and the linkee has failed (e.g., linkee process died, a network error occurred). In this situation, the remote linkee process might still be running.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42" title="Links with the specified UPID. ">process::ProcessBase::link</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#ac285ccb7495989feff13451400127c7f">mesos::internal::master::Master</a>, and <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#afc9437a65ba512cdfa4cd082b0e95d55">mesos::internal::slave::Slave</a>.</p>

</div>
</div>
<a class="anchor" id="a07ac3fd4eededbb6015c305e12411b98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a process is terminated. </p>
<p><b>NOTE</b>: this does not get invoked automatically if <code><a class="el" href="classprocess_1_1ProcessBase.html#a4dd3058269bffe1b73cb8a4469a66542">process::ProcessBase::consume(TerminateEvent&amp;&amp;)</a></code> is overridden. </p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#ade864dd7c63e16d0714c351381390cff">mesos::internal::master::Master</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#ac81938c4eeee7234af198a86c13911fc">mesos::internal::slave::Slave</a>, <a class="el" href="classNetworkProcess.html#a36b7e3c3759a96959823ee339fa68392">NetworkProcess</a>, <a class="el" href="classmesos_1_1internal_1_1recordio_1_1internal_1_1ReaderProcess.html#a591bf74929a5fc7db08c73c1761e7a50">mesos::internal::recordio::internal::ReaderProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogWriterProcess.html#ae90aff3b3439fb99379296db1ebff980">mesos::internal::log::LogWriterProcess</a>, <a class="el" href="classmesos_1_1internal_1_1HttpConnectionProcess.html#aae8683e301cded923007452565426324">mesos::internal::HttpConnectionProcess&lt; Call, Event &gt;</a>, <a class="el" href="classprocess_1_1SequenceProcess.html#a6eae0ed53077a4573c73d0a36ed7964d">process::SequenceProcess</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogReaderProcess.html#a7b1d0d66aee598f4a19c0b38010b5e42">mesos::internal::log::LogReaderProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1CgroupsIsolatorProcess.html#a28cc5ac3d37ed6a87db5c538c56bcb13">mesos::internal::slave::CgroupsIsolatorProcess</a>, <a class="el" href="classprocess_1_1RateLimiterProcess.html#a52f385d91c5420d62baef6c6054b408a">process::RateLimiterProcess</a>, <a class="el" href="classmesos_1_1internal_1_1checks_1_1CheckerProcess.html#a94f9ff395b1e85b748193a59399f4d86">mesos::internal::checks::CheckerProcess</a>, <a class="el" href="classprocess_1_1System.html#ac64aa6bb6638963782932ebfc140c952">process::System</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogProcess.html#ac9a5bbcfa324d5ef3abb72b2a307592d">mesos::internal::log::LogProcess</a>, and <a class="el" href="classprocess_1_1HttpProxy.html#a2d615bb9eb4117e46251fb80de6eafd0">process::HttpProxy</a>.</p>

</div>
</div>
<a class="anchor" id="a6baf49d6234eb638d068a98514e4ae3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a process gets spawned. </p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#a5ee20b895880bc157c7e445859458364">mesos::internal::master::Master</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#ace99b8066d4aed8f21395f025118fc10">mesos::internal::slave::Slave</a>, <a class="el" href="classmesos_1_1internal_1_1master_1_1Heartbeater.html#ac9ebf3a4eb46a4501e13bd38dcd96a5d">mesos::internal::master::Heartbeater&lt; Message, Event &gt;</a>, <a class="el" href="classprocess_1_1internal_1_1AwaitProcess.html#a8121fadd91f2221a673d4e711f22c948">process::internal::AwaitProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1storage_1_1UriDiskProfileAdaptorProcess.html#a45f01969efd7ec5404741deb9304fd8b">mesos::internal::storage::UriDiskProfileAdaptorProcess</a>, <a class="el" href="classmesos_1_1internal_1_1recordio_1_1internal_1_1ReaderProcess.html#af123bea3321a9d99d1fecaf33cd5179b">mesos::internal::recordio::internal::ReaderProcess&lt; T &gt;</a>, <a class="el" href="classzookeeper_1_1GroupProcess.html#a2bd94b2043dc0f484858eae235333439">zookeeper::GroupProcess</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogWriterProcess.html#a4896aaab8e6d04562965ea678034543e">mesos::internal::log::LogWriterProcess</a>, <a class="el" href="classprocess_1_1Help.html#ab60e978a150594aae173311d776483c5">process::Help</a>, <a class="el" href="classprocess_1_1internal_1_1CollectProcess.html#a6e13d430bd37e93903d3f0b4201b8e31">process::internal::CollectProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogReaderProcess.html#a7af658bc98f66d4ca187e02bfa303c6d">mesos::internal::log::LogReaderProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1CgroupsIsolatorProcess.html#af15917f9898bb6d74495dc163ea19ec1">mesos::internal::slave::CgroupsIsolatorProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1NetworkPortsIsolatorProcess.html#a51ab2b5a72800662b601ac52c750fe06">mesos::internal::slave::NetworkPortsIsolatorProcess</a>, <a class="el" href="classmesos_1_1internal_1_1checks_1_1CheckerProcess.html#a5e21e337ac863fd8da8ad861807d3c0f">mesos::internal::checks::CheckerProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1PerfEventSubsystem.html#a624c2b34dabb1615433c70fa03a04a0f">mesos::internal::slave::PerfEventSubsystem</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogProcess.html#ada6f3c8f17d59a9d78071542a02e6f7d">mesos::internal::log::LogProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1ContainerDaemonProcess.html#a88f13e39677ff8976ae20ccb5a5d2045">mesos::internal::slave::ContainerDaemonProcess</a>, <a class="el" href="classmesos_1_1internal_1_1VersionProcess.html#a1f0746cf6e384fc26bfd7e892fa464c2">mesos::internal::VersionProcess</a>, <a class="el" href="classmesos_1_1internal_1_1WhitelistWatcher.html#a554e828d1e5aa7a84c5b38ad20a7731f">mesos::internal::WhitelistWatcher</a>, <a class="el" href="classprocess_1_1System.html#a5cfa4acb240377af06c74eca269df423">process::System</a>, <a class="el" href="classprocess_1_1metrics_1_1internal_1_1MetricsProcess.html#a481de823013045447009d4554fdaf69d">process::metrics::internal::MetricsProcess</a>, <a class="el" href="classprocess_1_1Logging.html#aadc2611836b2e3e9f6ea667e06da4fa5">process::Logging</a>, <a class="el" href="classprocess_1_1MemoryProfiler.html#a51a6bf768a165ed59c410ce5c08b8838">process::MemoryProfiler</a>, <a class="el" href="classprocess_1_1internal_1_1ReaperProcess.html#afeb3d27d616c3c7c3b63f22eb0828dbf">process::internal::ReaperProcess</a>, and <a class="el" href="classprocess_1_1Profiler.html#a9131797d93999031d9e732c8a2d45da4">process::Profiler</a>.</p>

</div>
</div>
<a class="anchor" id="a591501723f8320f0b29e2a7c64a501eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::install </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for messages with the specified name. </p>

</div>
</div>
<a class="anchor" id="a8dfef5689de05716f582fa737f165133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::install </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for messages with the specified name. </p>

</div>
</div>
<a class="anchor" id="ae97b59a857843096aa219d0209837c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_1_1UPID.html">UPID</a> process::ProcessBase::link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a>&#160;</td>
          <td class="paramname"><em>remote</em> = <code><a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links with the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>
<p>Linking with a process from within the same OS process is guaranteed to give you perfect monitoring of that process.</p>
<p>Linking to a remote process establishes a persistent TCP connection to the remote libprocess instance that hosts that process. If the TCP connection fails, the true state of the remote linked process cannot be determined; we handle this situation by generating an <a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a>. </p>

</div>
</div>
<a class="anchor" id="a38a4b602aa7e2656a647323da1bacf50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::lost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a linked process can no longer be monitored. </p>
<p>TODO(neilc): This is not implemented.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42" title="Links with the specified UPID. ">process::ProcessBase::link</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b32f94df3a92225825a1cc426b060c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::provide </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em> = <code><a class="el" href="namespaceprocess_1_1mime.html#aa12bd84b9c99ba313fbbf8c56bc411cb">mime::types</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up the default HTTP request handler to provide the static asset(s) at the specified <em>absolute</em> path for the specified name. </p>
<p>For example, assuming the process named "server" invoked <code>provide("name", "path")</code>, then an HTTP request for <code>/server/name</code> would return the asset found at "path". If the specified path is a directory then an HTTP request for <code>/server/name/file</code> would return the asset found at <code>/path/file</code>.</p>
<p>The <code>Content-Type</code> header of the HTTP response will be set to the specified type given the file extension, which can be changed via the optional <code>types</code> parameter. </p>

</div>
</div>
<a class="anchor" id="af0d1a6f8da798dfb2b6ea92550b8c6f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for HTTP requests with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The endpoint or URL to route. Must begin with a <code>/</code> and must not end with a '/'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70ff038897726b5ff2713e5d5602efa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for HTTP requests with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The endpoint or URL to route. Must begin with a <code>/</code> and must not end with a '/'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bb721f72a1b9b517808149010de8b9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37cf86bbf94884960c041e081a34bee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards to the correct overload of <code><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route()</a></code>, depending on whether the authentication realm <code>realm</code> is present. </p>

</div>
</div>
<a class="anchor" id="a7ff87364baa79991901b8d73dc5c5fca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structprocess_1_1UPID.html">UPID</a>&amp; process::ProcessBase::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af90d581940120abfb787e46568e7a3af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the message to the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>
<p>Prefer the rvalue reference overloads if the data can be moved in.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structprocess_1_1Message.html">process::Message</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a72621d5c290fc558dcffb62b7d05635b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab60d5a19d749f9f140b5ede6800549a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2accda04cb99a8337c501958ff85ce01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::serve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess_1_1Event.html">Event</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when an event is serviced. </p>

<p>Reimplemented in <a class="el" href="classprocess_1_1internal_1_1ThunkProcess.html#ae2e5977cf5eda3b01f9487bcc1961aa0">process::internal::ThunkProcess&lt; R &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae1701c7594fe2cf1c96b951a52eb0396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ProcessManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf2e3480d3fd92960e1addaf8cc71d6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* schedule </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43e117b196c850619d5255046edb3e79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classprocess_1_1SocketManager.html">SocketManager</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2f0e2769d84e1491c180d0da6458624b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhashmap.html">hashmap</a>&lt;std::string, HttpEndpoint&gt; process::ProcessBase::http</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55a5326c3f9b66bc56cc13c7bf4c350d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Owned.html">Owned</a>&lt;<a class="el" href="classprocess_1_1Sequence.html">Sequence</a>&gt; process::ProcessBase::httpSequence</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb219ae4b5e8dab3f724e78032e03d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhashmap.html">hashmap</a>&lt;std::string, <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a>&gt; process::ProcessBase::message</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>3rdparty/libprocess/include/process/<a class="el" href="libprocess_2include_2process_2process_8hpp_source.html">process.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
