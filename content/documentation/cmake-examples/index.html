<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Apache Mesos - CMake By Example</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:locale" content="en_US"/>
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Apache Mesos"/>
    <meta property="og:site_name" content="Apache Mesos"/>
    <meta property="og:url" content="https://mesos.apache.org/"/>
    <meta property="og:image" content="https://mesos.apache.org/assets/img/mesos_logo_fb_preview.png"/>
    <meta property="og:description"
          content="Apache Mesos abstracts resources away from machines,
                   enabling fault-tolerant and elastic distributed systems
                   to easily be built and run effectively."/>

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ApacheMesos"/>
    <meta name="twitter:title" content="Apache Mesos"/>
    <meta name="twitter:image" content="https://mesos.apache.org/assets/img/mesos_logo_fb_preview.png"/>
    <meta name="twitter:description"
          content="Apache Mesos abstracts resources away from machines,
                   enabling fault-tolerant and elastic distributed systems
                   to easily be built and run effectively."/>

    <link href="../../assets/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="alternate" type="application/atom+xml" title="Apache Mesos Blog" href="/blog/feed.xml">
    <link href="../../assets/css/main.css" rel="stylesheet" />


  </head>
  <body>
    <!-- magical breadcrumbs -->
    <div class="topnav">
      <div class="container">
        <ul class="breadcrumb">
          <li>
            <div class="dropdown">
              <a data-toggle="dropdown" href="#">Apache Software Foundation <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
                <li><a href="https://www.apache.org">Apache Homepage</a></li>
                <li><a href="https://www.apache.org/licenses/">License</a></li>
                <li><a href="https://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
                <li><a href="https://www.apache.org/foundation/thanks.html">Thanks</a></li>
                <li><a href="https://www.apache.org/security/">Security</a></li>
              </ul>
            </div>
          </li>

          <li><a href="https://mesos.apache.org">Apache Mesos</a></li>
          <li><a href="/documentation/">Documentation</a></li>
        </ul><!-- /.breadcrumb -->
      </div><!-- /.container -->
    </div><!-- /.topnav -->

    <!-- navbar excitement -->
<div class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#mesos-menu" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/"><img src="/assets/img/mesos_logo.png" alt="Apache Mesos logo"/></a>
    </div><!-- /.navbar-header -->

    <div class="navbar-collapse collapse" id="mesos-menu">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/getting-started/">Getting Started</a></li>
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/documentation/latest/">Documentation</a></li>
        <li><a href="/downloads/">Downloads</a></li>
        <li><a href="/community/">Community</a></li>
      </ul>
    </div><!-- /#mesos-menu -->
  </div><!-- /.container -->
</div><!-- /.navbar -->

<div class="content">
  <div class="container">
    <div class="row-fluid">
  <div class="col-md-4">
    <h4>If you're new to Mesos</h4>
    <p>See the <a href="/getting-started/">getting started</a> page for more
       information about downloading, building, and deploying Mesos.</p>

    <h4>If you'd like to get involved or you're looking for support</h4>
    <p>See our <a href="/community/">community</a> page for more details.</p>
  </div>
  <div class="col-md-8">
    <h1>Adding a new library or executable</h1>

<p>When adding a new library or executable, prefer using the name directly as the
target. E.g. <code>libprocess</code> is <code>add_library(process)</code>, and <code>mesos-agent</code> is
<code>add_executable(mesos-agent)</code>. Note that, on platforms where it is conventional,
<code>add_library</code> will prepend <code>lib</code> when writing the library to disk.</p>

<p>Do not introduce a variable simply to hold the name of the target; if the name
on disk needs to be a specific value, set the target property <code>OUTPUT_NAME</code>.</p>

<h1>Adding a third-party dependency</h1>

<p>When adding a third-party dependency, keep the principle of locality in mind.
All necessary data for building with and linking to the library should
be defined where the library is imported. A consumer of the dependency should
only have to add <code>target_link_libraries(consumer dependency)</code>, with every other
build property coming from the graph (library location, include directories,
compiler definitions, etc.).</p>

<p>The steps to add a new third-party dependency are:</p>

<ol>
<li>Add the version and SHA256 hash to <code>Versions.cmake</code>.</li>
<li>Add the URL/tarball file to the top of <code>3rdparty/CMakeLists.txt</code>.</li>
<li>Find an appropriate location in <code>3rdparty/CMakeLists.txt</code> to declare the
 library. Add a nice header with the name, description, and home page.</li>
<li>Use <code>add_library(IMPORTED)</code> to declare an imported target.
 A header-only library is imported with <code>add_library(INTERFACE)</code>.</li>
<li>Use <a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html"><code>ExternalProject_Add</code></a> to obtain, configure, and build the library.</li>
<li>Link the consumer to the dependency.</li>
</ol>


<h2><code>INTERFACE</code> libraries</h2>

<p>Using header-only libraries in CMake is a breeze. The special <code>INTERFACE</code>
library lets you declare a header-only library as a proper CMake target, and
then use it like any other library. Let&rsquo;s look at Boost for an example.</p>

<p>First, we add two lines to <code>Versions.cmake</code>:</p>

<pre><code>set(BOOST_VERSION "1.53.0")
set(BOOST_HASH    "SHA256=CED7CE2ED8D7D34815AC9DB1D18D28FCD386FFBB3DE6DA45303E1CF193717038")
</code></pre>

<p>This lets us keep the versions (and the SHA256 hash of the tarball) of all our
third-party dependencies in one location.</p>

<p>Second, we add one line to the top of <code>3rdparty/CMakeLists.txt</code> to declare the
location of the tarball:</p>

<pre><code>set(BOOST_URL ${FETCH_URL}/boost-${BOOST_VERSION}.tar.gz)
</code></pre>

<p>The <code>FETCH_URL</code> variable lets the <code>REBUNDLED</code> option switch between offline and
online versions. The use of <code>BOOST_VERSION</code> shows why this variable is declared
early; it&rsquo;s used a few times.</p>

<p>Third, we find a location in <code>3rdparty/CMakeLists.txt</code> to declare the Boost
library.</p>

<pre><code># Boost: C++ Libraries.
# http://www.boost.org
#######################
...
</code></pre>

<p>We start with a proper header naming and describing the library, complete with
its home page URL. This is for other developers to easily identify why this
third-party dependency exists.</p>

<pre><code>...
EXTERNAL(boost ${BOOST_VERSION} ${CMAKE_CURRENT_BINARY_DIR})
add_library(boost INTERFACE)
add_dependencies(boost ${BOOST_TARGET})
target_include_directories(boost INTERFACE ${BOOST_ROOT})
...
</code></pre>

<p>Fourth, we declare the Boost target.</p>

<p>To make things easier, we invoke our custom CMake function <code>EXTERNAL</code> to setup
some variables for us: <code>BOOST_TARGET</code>, <code>BOOST_ROOT</code>, and <code>BOOST_CMAKE_ROOT</code>. See
<a href="/documentation/latest/./cmake/#EXTERNAL">the docs</a> for more explanation of <code>EXTERNAL</code>.</p>

<p>Then we call <code>add_library(boost INTERFACE)</code>. This creates a header-only CMake
target, usable like any other library. We use <code>add_dependencies(boost
${BOOST_TARGET})</code> to add a manual dependency on the <code>ExternalProject_Add</code> step;
this is necessary as CMake is lazy and won&rsquo;t execute code unless it must (say,
because of a dependency). The final part of creating this header-only library in
our build system is <code>target_include_directories(boost INTERFACE
${BOOST_ROOT})</code>, which sets the <code>BOOST_ROOT</code> folder (the destination of the
extracted headers) as the include interface for the <code>boost</code> target. All
dependencies on Boost will now automatically include this folder during
compilation.</p>

<p>Fifth, we setup the <code>ExternalProject_Add</code> step. This CMake module is incredibly
flexible, but we&rsquo;re using it in the simplest case.</p>

<pre><code>...
ExternalProject_Add(
  ${BOOST_TARGET}
  PREFIX            ${BOOST_CMAKE_ROOT}
  CONFIGURE_COMMAND ${CMAKE_NOOP}
  BUILD_COMMAND     ${CMAKE_NOOP}
  INSTALL_COMMAND   ${CMAKE_NOOP}
  URL               ${BOOST_URL}
  URL_HASH          ${BOOST_HASH})
</code></pre>

<p>The name of the custom target this creates is <code>BOOST_TARGET</code>, and the prefix
directory for all the subsequent steps is <code>BOOST_CMAKE_ROOT</code>. Because this is a
header-only library, and <code>ExternalProject_Add</code> defaults to invoking <code>cmake</code>, we
use <code>CMAKE_NOOP</code> to disable the configure, build, and install commands. See <a href="/documentation/latest/./cmake/#cmake_noop">the
docs</a> for more explanation of <code>CMAKE_NOOP</code>. Thus this code
will simply verify the tarball with <code>BOOST_HASH</code>, and then extract it from
<code>BOOST_URL</code> to <code>BOOST_ROOT</code> (a sub-folder of <code>BOOST_CMAKE_ROOT</code>).</p>

<p>Sixth, and finally, we link <code>stout</code> to <code>boost</code>. This is the <em>only</em> change
necessary to <code>3rdparty/stout/CMakeLists.txt</code>, as the include directory
information is embedded in the CMake graph.</p>

<pre><code>target_link_libraries(
  stout INTERFACE
  ...
  boost
  ...)
</code></pre>

<p>This dependency need not be specified again, as <code>libprocess</code> and <code>libmesos</code> link
to <code>stout</code>, and so <code>boost</code> is picked up transitively.</p>

<h3>Stout</h3>

<p>Stout is a header-only library. Like Boost, it is a real CMake target, declared
in <code>3rdparty/stout/CMakeLists.txt</code>, just without the external bits.</p>

<pre><code>add_library(stout INTERFACE)
target_include_directories(stout INTERFACE include)
target_link_libraries(
  stout INTERFACE
  apr
  boost
  curl
  elfio
  glog
  ...)
</code></pre>

<p>It is added as an <code>INTERFACE</code> library. Its include directory is specified as an
<code>INTERFACE</code> (the <code>PUBLIC</code> property cannot be used as the library itself is just
an interface). Its &ldquo;link&rdquo; dependencies (despite not being a real, linkable
library) are specified as an <code>INTERFACE</code>.</p>

<p>This notion of an interface in the CMake dependency graph is what makes the
build system reasonable. The Mesos library and executables, and <code>libprocess</code>, do
not have to repeat these lower level dependencies that come from <code>stout</code>.</p>

<h2><code>IMPORTED</code> libraries</h2>

<p>Third-party dependencies that we build are only more complicated because we have
to encode their build steps too. We&rsquo;ll examine <code>glog</code>, and go over the
differences from the interface library <code>boost</code>.</p>

<p>Notably, when we declare the library, we use:</p>

<pre><code>add_library(glog ${LIBRARY_LINKAGE} IMPORTED GLOBAL)
</code></pre>

<p>Instead of <code>INTERFACE</code> we specify <code>IMPORTED</code> as it is an actual library. We add
<code>GLOBAL</code> to enable our pre-compiled header module <code>cotire</code> to find the targets
(as they would otherwise be scoped only to <code>3rdparty</code> and below). And most
oddly, we use <code>${LIBRARY_LINKAGE}</code> to set it as <code>SHARED</code> or <code>STATIC</code> based on
<code>BUILD_SHARED_LIBS</code>, as we can build this dependency in both manners. See <a href="/documentation/latest/./cmake/#library_linkage">the
docs</a> for more information.</p>

<p>We must patch our bundled version of <code>glog</code> so we call:</p>

<pre><code>PATCH_CMD(GLOG_PATCH_CMD glog-${GLOG_VERSION}.patch)
</code></pre>

<p>This generates a patch command. See <a href="/documentation/latest/./cmake/#patch_cmd">the docs</a> for more
information.</p>

<p>This library is an example of where we differ on Windows and other platforms. On
Windows, we build <code>glog</code> with CMake, and have several properties we must set:</p>

<pre><code>set_target_properties(
  glog PROPERTIES
  IMPORTED_LOCATION_DEBUG ${GLOG_ROOT}-build/Debug/glog${LIBRARY_SUFFIX}
  IMPORTED_LOCATION_RELEASE ${GLOG_ROOT}-build/Release/glog${LIBRARY_SUFFIX}
  IMPORTED_IMPLIB_DEBUG ${GLOG_ROOT}-build/Debug/glog${CMAKE_IMPORT_LIBRARY_SUFFIX}
  IMPORTED_IMPLIB_RELEASE ${GLOG_ROOT}-build/Release/glog${CMAKE_IMPORT_LIBRARY_SUFFIX}
  INTERFACE_INCLUDE_DIRECTORIES ${GLOG_ROOT}/src/windows
  # TODO(andschwa): Remove this when glog is updated.
  IMPORTED_LINK_INTERFACE_LIBRARIES DbgHelp
  INTERFACE_COMPILE_DEFINITIONS "${GLOG_COMPILE_DEFINITIONS}")
</code></pre>

<p>The location of an imported library <em>must</em> be set for the build system to link
to it. There is no notion of search through link directories for imported
libraries.</p>

<p>Windows requires both the <code>DEBUG</code> and <code>RELEASE</code> locations of the library
specified, and since we have (experimental) support to build <code>glog</code> as a shared
library on Windows, we also have to declare the <code>IMPLIB</code> location. Fortunately,
these locations are programmatic based of <code>GLOG_ROOT</code>, set from our call to
<code>EXTERNAL</code>.</p>

<p>Note that we cannot use <code>target_include_directories</code> with an imported target. We
have to set <code>INTERFACE_INCLUDE_DIRECTORIES</code> manually instead.</p>

<p>This version of <code>glog</code> on Windows depends on <code>DbgHelp</code> but does not use a
<code>#pragma</code> to include it, so we set it as an interface library that must also be
linked, using the <code>IMPORTED_LINK_INTERFACE_LIBRARIES</code> property.</p>

<p>For Windows there are multiple compile definitions that must be set when
building with the <code>glog</code> headers, these are specified with the
<code>INTERFACE_COMPILE_DEFINITIONS</code> property.</p>

<p>For non-Windows platforms, we just set the Autotools commands to configure,
make, and install <code>glog</code>. These commands depend on the project requirements. We
also set the <code>IMPORTED_LOCATION</code> and <code>INTERFACE_INCLUDE_DIRECTORIES</code>.</p>

<pre><code>set(GLOG_CONFIG_CMD  ${GLOG_ROOT}/src/../configure --with-pic GTEST_CONFIG=no --prefix=${GLOG_ROOT}-build)
set(GLOG_BUILD_CMD   make)
set(GLOG_INSTALL_CMD make install)

set_target_properties(
  glog PROPERTIES
  IMPORTED_LOCATION ${GLOG_ROOT}-build/lib/libglog${LIBRARY_SUFFIX}
  INTERFACE_INCLUDE_DIRECTORIES ${GLOG_ROOT}-build/include)
</code></pre>

<p>To work around some issues, we have to call <code>MAKE_INCLUDE_DIR(glog)</code> to create
the include directory immediately so as to satisfy CMake&rsquo;s requirement that it
exists (it will be populated by <code>ExternalProject_Add</code> during the build, but must
exist first). See <a href="/documentation/latest/./cmake/#make_include_dir">the docs</a> for more information.</p>

<p>Then call <code>GET_BYPRODUCTS(glog)</code> to create the <code>GLOG_BYPRODUCTS</code> variable, which
is sent to <code>ExternalProject_Add</code> to make the Ninja build generator happy. See
<a href="/documentation/latest/./cmake/#get_byproducts">the docs</a> for more information.</p>

<pre><code>MAKE_INCLUDE_DIR(glog)
GET_BYPRODUCTS(glog)
</code></pre>

<p>Like with Boost, we call <code>ExternalProject_Add</code>:</p>

<pre><code>ExternalProject_Add(
  ${GLOG_TARGET}
  PREFIX            ${GLOG_CMAKE_ROOT}
  BUILD_BYPRODUCTS  ${GLOG_BYPRODUCTS}
  PATCH_COMMAND     ${GLOG_PATCH_CMD}
  CMAKE_ARGS        ${CMAKE_FORWARD_ARGS};-DBUILD_TESTING=OFF
  CONFIGURE_COMMAND ${GLOG_CONFIG_CMD}
  BUILD_COMMAND     ${GLOG_BUILD_CMD}
  INSTALL_COMMAND   ${GLOG_INSTALL_CMD}
  URL               ${GLOG_URL}
  URL_HASH          ${GLOG_HASH})
</code></pre>

<p>In contrast to an interface library, we need to send all the build information,
which we set in variables prior. This includes the <code>BUILD_BYPRODUCTS</code>, and the
<code>PATCH_COMMAND</code> as we have to patch <code>glog</code>.</p>

<p>Since we build <code>glog</code> with CMake on Windows, we have to set <code>CMAKE_ARGS</code> with
the <code>CMAKE_FORWARD_ARGS</code>, and particular to <code>glog</code>, we disable its tests with
<code>-DBUILD_TESTING=OFF</code>, though this is not a canonical CMake option.</p>

<p>On Linux, we set the config, build, and install commands, and send them too.
These are empty on Windows, so <code>ExternalProject_Add</code> will fallback to using
CMake, as we needed.</p>

<p>Finally, we add <code>glog</code> to as a link library to <code>stout</code>:</p>

<pre><code>target_link_libraries(
  stout INTERFACE
  ...
  glog
  ...)
</code></pre>

<p>No other code is necessary, we have completed adding, building, and linking to
<code>glog</code>. The same patterns can be adapted for any other third-party dependency.</p>

<h1>Building debug or release configurations</h1>

<p>The default configuration is always <code>Debug</code>, which means with debug symbols and
without (many) optimizations. Of course, when deploying Mesos an optimized
<code>Release</code> build is desired. This is one of the few inconsistencies in CMake, and
it&rsquo;s due to the difference between so-called &ldquo;single-configuration generators&rdquo;
(such as GNU Make) and &ldquo;multi-configuration generators&rdquo; (such as Visual Studio).</p>

<h2>Configuration-time configurations</h2>

<p>In single-configuration generators, the configuration (debug or release) is
chosen at configuration time (that is, when initially calling <code>cmake</code> to
configure the build), and it is not changeable without re-configuring. So
building a <code>Release</code> configuration on Linux (with GNU Make) is done via:</p>

<pre><code>cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
</code></pre>

<h2>Build-time configurations</h2>

<p>However, the Visual Studio generator on Windows allows the developer to change
the release at build-time, making it a multi-configuration generator. CMake
generates a configuration-agnostic solution (and so <code>CMAKE_BUILD_TYPE</code> is
ignored), and the user switches the configuration when building. This can be
done with the familiar configuration menu in the Visual Studio IDE, or with
CMake via:</p>

<pre><code>cmake ..
cmake --build . --config Release
</code></pre>

<p>In the same build folder, a <code>Debug</code> build can also be built, with the binaries
stored in <code>Debug</code> and <code>Release</code> folders respectively. Unfortunately, the current
CMake build explicitly sets the final binary destination directories, and so the
final libraries and executables will overwrite each other when building
different configurations.</p>

<p>Note that Visual Studio is not the only IDE that uses a multi-configuration
generator, Xcode on Mac OS X does as well.
See <a href="https://issues.apache.org/jira/browse/MESOS-7943">MESOS-7943</a> for more information.</p>

<h2>Building with shared or static libraries</h2>

<p>On Linux, the configuration option <code>-DBUILD_SHARED_LIBS=FALSE</code> can be used to
switch to static libraries where possible. Otherwise Linux builds shared
libraries by default.</p>

<p>On Windows, static libraries are the default. Building with shared libraries on
Windows is not yet supported, as it requires code change to import symbols
properly.</p>

  </div>
</div>

  </div><!-- /.container -->
</div><!-- /.content -->

<hr>



    <!-- footer -->
    <div class="footer">
      <div class="container">

        <div class="col-md-12 trademark">
          <p>&copy; 2012-2022 <a href="https://apache.org">The Apache Software Foundation</a>.
            Apache Mesos, the Apache feather logo, and the Apache Mesos project logo are trademarks of The Apache Software Foundation.
          <p>
        </div>

      </div><!-- /.container -->
    </div><!-- /.footer -->

    <!-- JS -->
    <script src="../../assets/js/jquery-1.11.0.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
    <script src="../../assets/js/anchor-4.1.0.min.js"></script>

    <!-- Inject anchors for all headings on the page, see https://www.bryanbraun.com/anchorjs. -->
    <script type="text/javascript">
    anchors.options = {
      placement: 'right',
      ariaLabel: 'Permalink',
    };

    // The default is to not add anchors to h1, but we have pages with multiple h1 headers,
    // and we do want to put anchors on those.
    anchors.add('h1, h2, h3, h4, h5, h6');
    </script>
  </body>
</html>
