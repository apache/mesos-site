<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Apache Mesos - Framework Development Guide</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:locale" content="en_US"/>
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Apache Mesos"/>
    <meta property="og:site_name" content="Apache Mesos"/>
    <meta property="og:url" content="http://mesos.apache.org/"/>
    <meta property="og:image" content="http://mesos.apache.org/assets/img/mesos_logo_fb_preview.png"/>
    <meta property="og:description"
          content="Apache Mesos abstracts resources away from machines,
                   enabling fault-tolerant and elastic distributed systems
                   to easily be built and run effectively."/>

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ApacheMesos"/>
    <meta name="twitter:title" content="Apache Mesos"/>
    <meta name="twitter:image" content="http://mesos.apache.org/assets/img/mesos_logo_fb_preview.png"/>
    <meta name="twitter:description"
          content="Apache Mesos abstracts resources away from machines,
                   enabling fault-tolerant and elastic distributed systems
                   to easily be built and run effectively."/>

    <link href="../../../assets/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="alternate" type="application/atom+xml" title="Apache Mesos Blog" href="/blog/feed.xml">
    <link href="../../../assets/css/main.css" rel="stylesheet" />


  </head>
  <body>
    <!-- magical breadcrumbs -->
    <div class="topnav">
      <div class="container">
        <ul class="breadcrumb">
          <li>
            <div class="dropdown">
              <a data-toggle="dropdown" href="#">Apache Software Foundation <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
                <li><a href="http://www.apache.org">Apache Homepage</a></li>
                <li><a href="http://www.apache.org/licenses/">License</a></li>
                <li><a href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
                <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
                <li><a href="http://www.apache.org/security/">Security</a></li>
              </ul>
            </div>
          </li>

          <li><a href="http://mesos.apache.org">Apache Mesos</a></li>
          <li><a href="/documentation/">Documentation</a></li>
        </ul><!-- /.breadcrumb -->
      </div><!-- /.container -->
    </div><!-- /.topnav -->

    <!-- navbar excitement -->
<div class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#mesos-menu" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/"><img src="/assets/img/mesos_logo.png" alt="Apache Mesos logo"/></a>
    </div><!-- /.navbar-header -->

    <div class="navbar-collapse collapse" id="mesos-menu">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/getting-started/">Getting Started</a></li>
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/documentation/latest/">Documentation</a></li>
        <li><a href="/downloads/">Downloads</a></li>
        <li><a href="/community/">Community</a></li>
      </ul>
    </div><!-- /#mesos-menu -->
  </div><!-- /.container -->
</div><!-- /.navbar -->

<div class="content">
  <div class="container">
    <div class="row-fluid">
  <div class="col-md-4">
    <h4>If you're new to Mesos</h4>
    <p>See the <a href="/getting-started/">getting started</a> page for more
       information about downloading, building, and deploying Mesos.</p>

    <h4>If you'd like to get involved or you're looking for support</h4>
    <p>See our <a href="/community/">community</a> page for more details.</p>
  </div>
  <div class="col-md-8">
    <h1>Framework Development Guide</h1>

<p>In this document we refer to Mesos applications as &ldquo;frameworks&rdquo;.</p>

<p>See one of the example framework schedulers in <code>MESOS_HOME/src/examples/</code> to
get an idea of what a Mesos framework scheduler and executor in the language
of your choice looks like. <a href="https://github.com/mesosphere/RENDLER">RENDLER</a>
provides example framework implementations in C++, Go, Haskell, Java, Python
and Scala.</p>

<h2>Create your Framework Scheduler</h2>

<h3>API</h3>

<p>If you are writing a scheduler against Mesos 1.0 or newer, it is recommended
to use the new <a href="/documentation/latest/./scheduler-http-api/">HTTP API</a> to talk to Mesos.</p>

<p>If your framework needs to talk to Mesos 0.28.0 or older, or you have not updated to the
<a href="/documentation/latest/./scheduler-http-api/">HTTP API</a>, you can write the scheduler in C++, Java/Scala, or Python.
Your framework scheduler should inherit from the <code>Scheduler</code> class
(see: <a href="https://github.com/apache/mesos/blob/1.6.0/include/mesos/scheduler.hpp#L58-L177">C++</a>,
<a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Scheduler.html">Java</a>,
<a href="https://github.com/apache/mesos/blob/1.6.0/src/python/interface/src/mesos/interface/__init__.py#L34-L137">Python</a>). Your scheduler should create a SchedulerDriver (which will mediate
communication between your scheduler and the Mesos master) and then call <code>SchedulerDriver.run()</code>
(see: <a href="https://github.com/apache/mesos/blob/1.6.0/include/mesos/scheduler.hpp#L180-L317">C++</a>,
<a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/SchedulerDriver.html">Java</a>,
<a href="https://github.com/apache/mesos/blob/1.6.0/src/python/interface/src/mesos/interface/__init__.py#L140-L278">Python</a>).</p>

<h3>High Availability</h3>

<p>How to build Mesos frameworks that are highly available in the face of failures is
discussed in a <a href="/documentation/latest/./high-availability-framework-guide/">separate document</a>.</p>

<h3>Multi-Scheduler Scalability</h3>

<p>When implementing a scheduler, it&rsquo;s important to adhere to the following guidelines
in order to ensure that the scheduler can run in a scalable manner alongside other
schedulers in the same Mesos cluster:</p>

<ol>
<li><strong>Use <code>Suppress</code></strong>: The scheduler must stay in a suppressed state whenever it has
no additional tasks to launch or offer operations to perform. This ensures
that Mesos can more efficiently offer resources to those frameworks that do
have work to perform.</li>
<li><strong>Do not hold onto offers</strong>: If an offer cannot be used, decline it immediately.
Otherwise the resources cannot be offered to other schedulers and the scheduler
itself will receive fewer additional offers.</li>
<li><strong><code>Decline</code> resources using a large timeout</strong>: when declining an offer, use a
large <code>Filters.refuse_seconds</code> timeout (e.g. 1 hour). This ensures that Mesos
will have time to try offering the resources to other scheduler before trying
the same scheduler again. However, if the scheduler is unable to eventually
enter a <code>SUPPRESS</code>ed state, and it has new workloads to run after having declined,
it should consider <code>REVIVE</code>ing if it is not receiving sufficient resources for
some time.</li>
<li><strong>Do not <code>REVIVE</code> frequently</strong>: <code>REVIVE</code>ing clears all filters, and therefore
if <code>REVIVE</code> occurs frequently it is similar to always declining with a very
short timeout (violation of guideline (3)).</li>
<li><strong>Use <code>FrameworkInfo.offer_filters</code></strong>: This allows the scheduler to specify
global offer filters (<code>Decline</code> filters, on the other hand, are per-agent).
Currently supported is <code>OfferFilters.min_allocatable_resources</code> which acts as
an override of the cluster level <code>--min_allocatable_resources</code> master flag for
each of the scheduler&rsquo;s roles. Keeping the <code>FrameworkInfo.offer_filters</code>
up-to-date with the minimum desired offer shape for each role will ensure that
the sccheduler gets a better chance to receive offers sized with sufficient
resources.</li>
<li>Consider specifying <strong>offer constraints</strong> via <code>SUBSCRIBE</code>/<code>UPDATE_FRAMEWORK</code>
calls so that the framework role&rsquo;s quota is not consumed by offers that the
scheduler will have to decline anyway based on agent attributes.
See <a href="https://issues.apache.org/jira/browse/MESOS-10161]">MESOS-10161</a>
and <a href="https://github.com/apache/mesos/blob/master/include/mesos/v1/scheduler/scheduler.proto">scheduler.proto</a>
for more details.</li>
</ol>


<p>Operationally, the following can be done to ensure that schedulers get the resources
they need when co-existing with other schedulers:</p>

<ol>
<li><strong>Do not share a role between schedulers</strong>: Roles are the level at which controls
are available (e.g. quota, weight, reservation) that affect resource allocation.
Within a role, there are no controls to alter the behavior should one scheduler
not receive enough resources.</li>
<li><strong>Set quota if roles need a guarantee</strong>: If a role (either an entire scheduler or
a &ldquo;job&rdquo;/&ldquo;service&rdquo;/etc within a multi-tenant scheduler) needs a certain amount of
resources guaranteed to it, setting a quota ensures that Mesos will try its best
to allocate to satisfy the guarantee.</li>
<li><strong>Set the minimum allocatable resources</strong>: Once quota is used, the
<code>--min_allocatable_resources</code> flag should be set
(e.g. <code>--min_allocatable_resources=cpus:0.1,mem:32:disk:32</code>) to prevent offers
that are missing cpu, memory, or disk
(see <a href="https://issues.apache.org/jira/browse/MESOS-8935">MESOS-8935</a>).</li>
<li><strong>Consider enabling the random sorter</strong>: Depending on the use case, DRF can prove
problematic in that it will try to allocate to frameworks with a low share of the
cluster and penalize frameworks with a high share of the cluster. This can lead
to offer starvation for higher share frameworks. To allocate using a weighted
random uniform distribution instead of fair sharing, set <code>--role_sorter=random</code>
and <code>--framework_sorter=random</code> (see
<a href="https://issues.apache.org/jira/browse/MESOS-8936">MESOS-8936</a>).</li>
</ol>


<p>See the <a href="https://docs.google.com/document/d/1uvTmBo_21Ul9U_mijgWyh7hE0E_yZXrFr43JIB9OCl8">Offer Starvation Design Document</a>
in <a href="https://issues.apache.org/jira/browse/MESOS-3202">MESOS-3202</a> for more
information about the pitfalls and future plans for running multiple schedulers.</p>

<h2>Working with Executors</h2>

<h3>Using the Mesos Command Executor</h3>

<p>Mesos provides a simple executor that can execute shell commands and Docker
containers on behalf of the framework scheduler; enough functionality for a
wide variety of framework requirements.</p>

<p>Any scheduler can make use of the Mesos command executor by filling in the
optional <code>CommandInfo</code> member of the <code>TaskInfo</code> protobuf message.</p>

<pre><code class="{.proto}">message TaskInfo {
  ...
  optional CommandInfo command = 7;
  ...
}
</code></pre>

<p>The Mesos slave will fill in the rest of the <code>ExecutorInfo</code> for you when tasks
are specified this way.</p>

<p>Note that the agent will derive an <code>ExecutorInfo</code> from the <code>TaskInfo</code> and
additionally copy fields (e.g., <code>Labels</code>) from <code>TaskInfo</code> into the new
<code>ExecutorInfo</code>. This <code>ExecutorInfo</code> is only visible on the agent.</p>

<h3>Using the Mesos Default Executor</h3>

<p>Since Mesos 1.1, a new built-in default executor (<strong>experimental</strong>) is available that
can execute a group of tasks. Just like the command executor the tasks can be shell
commands or Docker containers.</p>

<p>The current semantics of the default executor are as folows:</p>

<p>&ndash; Task group is an atomic unit of deployment of a scheduler onto the default executor.</p>

<p>&ndash; The default executor can run one or more task groups (since Mesos 1.2) and each task group can be launched by the scheduler at different points in time.</p>

<p>&ndash; All task groups' tasks are launched as nested containers underneath the executor container.</p>

<p>&ndash; Task containers and executor container share resources like cpu, memory,
   network and volumes.</p>

<p>&ndash; Each task can have its own separate root file system (e.g., Docker image).</p>

<p>&ndash; There is no resource isolation between different tasks or task groups within an executor.
   Tasks' resources are added to the executor container.</p>

<p>&ndash; If any of the tasks exits with a non-zero exit code or killed by the scheduler, all the tasks in the task group
   are killed automatically. The default executor commits suicide if there are no active task groups.</p>

<p>Once the default executor is considered <strong>stable</strong>, the command executor will be deprecated in favor of it.</p>

<p>Any scheduler can make use of the Mesos default executor by setting <code>ExecutorInfo.type</code>
to <code>DEFAULT</code> when launching a group of tasks using the <code>LAUNCH_GROUP</code> offer operation.
If <code>DEFAULT</code> executor is explicitly specified when using <code>LAUNCH</code> offer operation, command
executor is used instead of the default executor. This might change in the future when the default
executor gets support for handling <code>LAUNCH</code> operation.</p>

<pre><code class="{.proto}">message ExecutorInfo {
  ...
    optional Type type = 15;
  ...
}
</code></pre>

<h3>Creating a custom Framework Executor</h3>

<p>If your framework has special requirements, you might want to provide your own
Executor implementation. For example, you may not want a 1:1 relationship
between tasks and processes.</p>

<p>If you are writing an executor against Mesos 1.0 or newer, it is recommended
to use the new <a href="/documentation/latest/./executor-http-api/">HTTP API</a> to talk to Mesos.</p>

<p>If writing against Mesos 0.28.0 or older, your framework executor must inherit
from the Executor class (see (see: <a href="https://github.com/apache/mesos/blob/1.6.0/include/mesos/executor.hpp#L60-L137">C++</a>,
<a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Executor.html">Java</a>,
<a href="https://github.com/apache/mesos/blob/1.6.0/src/python/interface/src/mesos/interface/__init__.py#L280-L344">Python</a>). It must override the launchTask() method. You can use
the $MESOS_HOME environment variable inside of your executor to determine where
Mesos is running from. Your executor should create an ExecutorDriver (which will
mediate communication between your executor and the Mesos agent) and then call
<code>ExecutorDriver.run()</code>
(see: <a href="https://github.com/apache/mesos/blob/1.6.0/include/mesos/executor.hpp#L140-L188">C++</a>,
<a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/ExecutorDriver.html">Java</a>,
<a href="https://github.com/apache/mesos/blob/1.6.0/src/python/interface/src/mesos/interface/__init__.py#L348-L401">Python</a>).</p>

<h4>Install your custom Framework Executor</h4>

<p>After creating your custom executor, you need to make it available to all slaves
in the cluster.</p>

<p>One way to distribute your framework executor is to let the
<a href="/documentation/latest/./fetcher/">Mesos fetcher</a> download it on-demand when your scheduler launches
tasks on that slave. <code>ExecutorInfo</code> is a Protocol Buffer Message class (defined
in <code>include/mesos/mesos.proto</code>), and it contains a field of type <code>CommandInfo</code>.
<code>CommandInfo</code> allows schedulers to specify, among other things, a number of
resources as URIs. These resources are fetched to a sandbox directory on the
slave before attempting to execute the <code>ExecutorInfo</code> command. Several URI
schemes are supported, including HTTP, FTP, HDFS, and S3 (e.g. see
src/examples/java/TestFramework.java for an example of this).</p>

<p>Alternatively, you can pass the <code>frameworks_home</code> configuration option
(defaults to: <code>MESOS_HOME/frameworks</code>) to your <code>mesos-slave</code> daemons when you
launch them to specify where your framework executors are stored (e.g. on an
NFS mount that is available to all slaves), then use a relative path in
<code>CommandInfo.uris</code>, and the slave will prepend the value of <code>frameworks_home</code>
to the relative path provided.</p>

<p>Once you are sure that your executors are available to the mesos-slaves, you
should be able to run your scheduler, which will register with the Mesos master,
and start receiving resource offers!</p>

<h2>Labels</h2>

<p><code>Labels</code> can be found in the <code>FrameworkInfo</code>, <code>TaskInfo</code>, <code>DiscoveryInfo</code> and
<code>TaskStatus</code> messages; framework and module writers can use Labels to tag and
pass unstructured information around Mesos. Labels are free-form key-value pairs
supplied by the framework scheduler or label decorator hooks. Below is the
protobuf definitions of labels:</p>

<pre><code class="{.proto}">  optional Labels labels = 11;
</code></pre>

<pre><code class="{.proto}">/**
 * Collection of labels.
 */
message Labels {
    repeated Label labels = 1;
}

/**
 * Key, value pair used to store free form user-data.
 */
message Label {
  required string key = 1;
  optional string value = 2;
}
</code></pre>

<p>Labels are not interpreted by Mesos itself, but will be made available over
master and slave state endpoints. Further more, the executor and scheduler can
introspect labels on the <code>TaskInfo</code> and <code>TaskStatus</code> programmatically.
Below is an example of how two label pairs (<code>"environment": "prod"</code> and
<code>"bananas": "apples"</code>) can be fetched from the master state endpoint.</p>

<pre><code class="{.sh}">$ curl http://master/state.json
...
{
  "executor_id": "default",
  "framework_id": "20150312-120017-16777343-5050-39028-0000",
  "id": "3",
  "labels": [
    {
      "key": "environment",
      "value": "prod"
    },
    {
      "key": "bananas",
      "value": "apples"
    }
  ],
  "name": "Task 3",
  "slave_id": "20150312-115625-16777343-5050-38751-S0",
  "state": "TASK_FINISHED",
  ...
},
</code></pre>

<h2>Service discovery</h2>

<p>When your framework registers an executor or launches a task, it can provide
additional information for service discovery. This information is stored by
the Mesos master along with other imporant information such as the slave
currently running the task. A service discovery system can programmatically
retrieve this information in order to set up DNS entries, configure proxies,
or update any consistent store used for service discovery in a Mesos cluster
that runs multiple frameworks and multiple tasks.</p>

<p>The optional <code>DiscoveryInfo</code> message for <code>TaskInfo</code> and <code>ExecutorInfo</code> is
declared in  <code>MESOS_HOME/include/mesos/mesos.proto</code></p>

<pre><code class="{.proto}">message DiscoveryInfo {
  enum Visibility {
    FRAMEWORK = 0;
    CLUSTER = 1;
    EXTERNAL = 2;
  }

  required Visibility visibility = 1;
  optional string name = 2;
  optional string environment = 3;
  optional string location = 4;
  optional string version = 5;
  optional Ports ports = 6;
  optional Labels labels = 7;
}
</code></pre>

<p><code>Visibility</code> is the key parameter that instructs the service discovery system
whether a service should be discoverable. We currently differentiate between
three cases:</p>

<ul>
<li>a task should not be discoverable for anyone but its framework.</li>
<li>a task should be discoverable for all frameworks running on the Mesos cluster
but not externally.</li>
<li>a task should be made discoverable broadly.</li>
</ul>


<p>Many service discovery systems provide additional features that manage the
visibility of services (e.g., ACLs in proxy based systems, security extensions
to DNS, VLAN or subnet selection). It is not the intended use of the visibility
field to manage such features. When a service discovery system retrieves the
task or executor information from the master, it can decide how to handle tasks
without <code>DiscoveryInfo</code>. For instance, tasks may be made non discoverable to
other frameworks (equivalent to <code>visibility=FRAMEWORK</code>) or discoverable to all
frameworks (equivalent to <code>visibility=CLUSTER</code>).</p>

<p>The <code>name</code> field is a string that provides the service discovery system
with the name under which the task is discoverable. The typical use of the name
field will be to provide a valid hostname. If name is not provided, it is up to
the service discovery system to create a name for the task based on the name
field in <code>taskInfo</code> or other information.</p>

<p>The <code>environment</code>, <code>location</code>, and <code>version</code> fields provide first class support
for common attributes used to differentiate between similar services in large
deployments. The <code>environment</code> may receive values such as <code>PROD/QA/DEV</code>, the
<code>location</code> field may receive values like <code>EAST-US/WEST-US/EUROPE/AMEA</code>, and the
<code>version</code> field may receive values like v2.0/v0.9. The exact use of these fields
is up to the service discovery system.</p>

<p>The <code>ports</code> field allows the framework to identify the ports a task listens to
and explicitly name the functionality they represent and the layer-4 protocol
they use (TCP, UDP, or other). For example, a Cassandra task will define ports
like <code>"7000,Cluster,TCP"</code>, <code>"7001,SSL,TCP"</code>, <code>"9160,Thrift,TCP"</code>,
<code>"9042,Native,TCP"</code>, and <code>"7199,JMX,TCP"</code>. It is up to the service discovery
system to use these names and protocol in appropriate ways, potentially
combining them with the <code>name</code> field in <code>DiscoveryInfo</code>.</p>

<p>The <code>labels</code> field allows a framework to pass arbitrary labels to the service
discovery system in the form of key/value pairs. Note that anything passed
through this field is not guaranteed to be supported moving forward.
Nevertheless, this field provides extensibility. Common uses of this field will
allow us to identify use cases that require first class support.</p>

  </div>
</div>

  </div><!-- /.container -->
</div><!-- /.content -->

<hr>



    <!-- footer -->
    <div class="footer">
      <div class="container">

        <div class="col-md-12 trademark">
          <p>&copy; 2012-2022 <a href="http://apache.org">The Apache Software Foundation</a>.
            Apache Mesos, the Apache feather logo, and the Apache Mesos project logo are trademarks of The Apache Software Foundation.
          <p>
        </div>

      </div><!-- /.container -->
    </div><!-- /.footer -->

    <!-- JS -->
    <script src="../../../assets/js/jquery-1.11.0.min.js"></script>
    <script src="../../../assets/js/bootstrap.min.js"></script>
    <script src="../../../assets/js/anchor-4.1.0.min.js"></script>

    <!-- Inject anchors for all headings on the page, see https://www.bryanbraun.com/anchorjs. -->
    <script type="text/javascript">
    anchors.options = {
      placement: 'right',
      ariaLabel: 'Permalink',
    };

    // The default is to not add anchors to h1, but we have pages with multiple h1 headers,
    // and we do want to put anchors on those.
    anchors.add('h1, h2, h3, h4, h5, h6');
    </script>
  </body>
</html>
