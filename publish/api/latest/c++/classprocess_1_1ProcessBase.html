<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Mesos: process::ProcessBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceprocess.html">process</a></li><li class="navelem"><a class="el" href="classprocess_1_1ProcessBase.html">ProcessBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classprocess_1_1ProcessBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">process::ProcessBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="libprocess_2include_2process_2process_8hpp_source.html">process.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for process::ProcessBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classprocess_1_1ProcessBase.png" usemap="#process::ProcessBase_map" alt=""/>
  <map id="process::ProcessBase_map" name="process::ProcessBase_map">
<area href="structprocess_1_1EventVisitor.html" alt="process::EventVisitor" shape="rect" coords="0,0,296,24"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; T &gt;" shape="rect" coords="306,112,602,136"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; AwaitProcess&lt; T &gt; &gt;" shape="rect" coords="306,168,602,192"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; CollectProcess&lt; T &gt; &gt;" shape="rect" coords="306,224,602,248"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; DockerContainerizerProcess &gt;" shape="rect" coords="306,280,602,304"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; FetcherProcess &gt;" shape="rect" coords="306,336,602,360"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; GarbageCollector &gt;" shape="rect" coords="306,392,602,416"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; GarbageCollectorProcess &gt;" shape="rect" coords="306,448,602,472"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; GroupProcess &gt;" shape="rect" coords="306,504,602,528"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; HealthCheckerProcess &gt;" shape="rect" coords="306,560,602,584"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Heartbeater &gt;" shape="rect" coords="306,616,602,640"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Help &gt;" shape="rect" coords="306,672,602,696"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Logging &gt;" shape="rect" coords="306,728,602,752"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogProcess &gt;" shape="rect" coords="306,784,602,808"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogReaderProcess &gt;" shape="rect" coords="306,840,602,864"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; LogWriterProcess &gt;" shape="rect" coords="306,896,602,920"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Master &gt;" shape="rect" coords="306,952,602,976"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosAllocatorProcess &gt;" shape="rect" coords="306,1008,602,1032"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosContainerizerProcess &gt;" shape="rect" coords="306,1064,602,1088"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MesosIsolatorProcess &gt;" shape="rect" coords="306,1120,602,1144"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; MetricsProcess &gt;" shape="rect" coords="306,1176,602,1200"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; NetworkProcess &gt;" shape="rect" coords="306,1232,602,1256"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Profiler &gt;" shape="rect" coords="306,1288,602,1312"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ProvisionerProcess &gt;" shape="rect" coords="306,1344,602,1368"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; RateLimiterProcess &gt;" shape="rect" coords="306,1400,602,1424"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReaderProcess&lt; T &gt; &gt;" shape="rect" coords="306,1456,602,1480"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReaperProcess &gt;" shape="rect" coords="306,1512,602,1536"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ReqResProcess&lt; Req, Res &gt; &gt;" shape="rect" coords="306,1568,602,1592"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; SequenceProcess &gt;" shape="rect" coords="306,1624,602,1648"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Slave &gt;" shape="rect" coords="306,1680,602,1704"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; Subsystem &gt;" shape="rect" coords="306,1736,602,1760"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; System &gt;" shape="rect" coords="306,1792,602,1816"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; ThunkProcess&lt; R &gt; &gt;" shape="rect" coords="306,1848,602,1872"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; VersionProcess &gt;" shape="rect" coords="306,1904,602,1928"/>
<area href="classprocess_1_1Process.html" alt="process::Process&lt; WhitelistWatcher &gt;" shape="rect" coords="306,1960,602,1984"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a318038bacd95e4260864533f7cfe12fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a318038bacd95e4260864533f7cfe12fd">ProcessBase</a> (const std::string &amp;id=&quot;&quot;)</td></tr>
<tr class="separator:a318038bacd95e4260864533f7cfe12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6c6b8f5aff506a97ce6c4f91a29d3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a20b6c6b8f5aff506a97ce6c4f91a29d3">~ProcessBase</a> ()</td></tr>
<tr class="separator:a20b6c6b8f5aff506a97ce6c4f91a29d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a9a47e9c36edb42e03bfb6adfee65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess_1_1UPID.html">UPID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#adc5a9a47e9c36edb42e03bfb6adfee65">self</a> () const </td></tr>
<tr class="separator:adc5a9a47e9c36edb42e03bfb6adfee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structprocess_1_1EventVisitor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structprocess_1_1EventVisitor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structprocess_1_1EventVisitor.html">process::EventVisitor</a></td></tr>
<tr class="memitem:ac13fa54ee331a688e72ef97b1e6b32ac inherit pub_methods_structprocess_1_1EventVisitor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocess_1_1EventVisitor.html#ac13fa54ee331a688e72ef97b1e6b32ac">~EventVisitor</a> ()</td></tr>
<tr class="separator:ac13fa54ee331a688e72ef97b1e6b32ac inherit pub_methods_structprocess_1_1EventVisitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a39f8e327dc132dd4a3a95fee650458f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a> { <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a>, 
<a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a435d743b35551ea7106af41c4a308c01">RemoteConnection::RECONNECT</a>
 }</td></tr>
<tr class="memdesc:a39f8e327dc132dd4a3a95fee650458f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of the <code>link</code> call when the target <code>pid</code> points to a remote process.  <a href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">More...</a><br/></td></tr>
<tr class="separator:a39f8e327dc132dd4a3a95fee650458f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ca53e513d7ead18e05466c60e51891"><td class="memItemLeft" align="right" valign="top">typedef lambda::function&lt; void(const <br class="typebreak"/>
<a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a></td></tr>
<tr class="memdesc:ab7ca53e513d7ead18e05466c60e51891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a "from" <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code> and a message body as arguments.  <a href="#ab7ca53e513d7ead18e05466c60e51891">More...</a><br/></td></tr>
<tr class="separator:ab7ca53e513d7ead18e05466c60e51891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d8346a62ad423899f6f9e9ee08806"><td class="memItemLeft" align="right" valign="top">typedef lambda::function<br class="typebreak"/>
&lt; <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;<br class="typebreak"/>
const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a></td></tr>
<tr class="memdesc:a083d8346a62ad423899f6f9e9ee08806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>.  <a href="#a083d8346a62ad423899f6f9e9ee08806">More...</a><br/></td></tr>
<tr class="separator:a083d8346a62ad423899f6f9e9ee08806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834b08377ce20a01893a033c46898f6"><td class="memItemLeft" align="right" valign="top">typedef lambda::function<br class="typebreak"/>
&lt; <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;<br class="typebreak"/>
 const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <br class="typebreak"/>
<a class="el" href="classOption.html">Option</a><br class="typebreak"/>
&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a></td></tr>
<tr class="memdesc:a0834b08377ce20a01893a033c46898f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and an <code><a class="el" href="classOption.html">Option</a>&lt;Principal&gt;</code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>.  <a href="#a0834b08377ce20a01893a033c46898f6">More...</a><br/></td></tr>
<tr class="separator:a0834b08377ce20a01893a033c46898f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a79814ca5804d56a805d43bc1c86ee1e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a79814ca5804d56a805d43bc1c86ee1e1">serve</a> (const <a class="el" href="structprocess_1_1Event.html">Event</a> &amp;event)</td></tr>
<tr class="memdesc:a79814ca5804d56a805d43bc1c86ee1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when an event is serviced.  <a href="#a79814ca5804d56a805d43bc1c86ee1e1">More...</a><br/></td></tr>
<tr class="separator:a79814ca5804d56a805d43bc1c86ee1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afada1b4232e2867717bc3cf6d296e2b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#afada1b4232e2867717bc3cf6d296e2b2">visit</a> (const <a class="el" href="structprocess_1_1MessageEvent.html">MessageEvent</a> &amp;event)</td></tr>
<tr class="separator:afada1b4232e2867717bc3cf6d296e2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7eb1f7b22934a2ae9787ec4129b879"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a9b7eb1f7b22934a2ae9787ec4129b879">visit</a> (const <a class="el" href="structprocess_1_1DispatchEvent.html">DispatchEvent</a> &amp;event)</td></tr>
<tr class="separator:a9b7eb1f7b22934a2ae9787ec4129b879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c225bbf6d2fd8f93e827ef3515a7e20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a6c225bbf6d2fd8f93e827ef3515a7e20">visit</a> (const <a class="el" href="structprocess_1_1HttpEvent.html">HttpEvent</a> &amp;event)</td></tr>
<tr class="separator:a6c225bbf6d2fd8f93e827ef3515a7e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f43bc1b3a1d1e1f9ea67772040902"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a394f43bc1b3a1d1e1f9ea67772040902">visit</a> (const <a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a> &amp;event)</td></tr>
<tr class="separator:a394f43bc1b3a1d1e1f9ea67772040902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a0d883ad4159e8780e6e1698a7c00a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a34a0d883ad4159e8780e6e1698a7c00a">visit</a> (const <a class="el" href="structprocess_1_1TerminateEvent.html">TerminateEvent</a> &amp;event)</td></tr>
<tr class="separator:a34a0d883ad4159e8780e6e1698a7c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf49d6234eb638d068a98514e4ae3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a6baf49d6234eb638d068a98514e4ae3f">initialize</a> ()</td></tr>
<tr class="memdesc:a6baf49d6234eb638d068a98514e4ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a process gets spawned.  <a href="#a6baf49d6234eb638d068a98514e4ae3f">More...</a><br/></td></tr>
<tr class="separator:a6baf49d6234eb638d068a98514e4ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ac3fd4eededbb6015c305e12411b98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a07ac3fd4eededbb6015c305e12411b98">finalize</a> ()</td></tr>
<tr class="memdesc:a07ac3fd4eededbb6015c305e12411b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a process is terminated.  <a href="#a07ac3fd4eededbb6015c305e12411b98">More...</a><br/></td></tr>
<tr class="separator:a07ac3fd4eededbb6015c305e12411b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0053b515e25f366a29a6897467bebc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0a0053b515e25f366a29a6897467bebc">exited</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;)</td></tr>
<tr class="memdesc:a0a0053b515e25f366a29a6897467bebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a linked process has exited.  <a href="#a0a0053b515e25f366a29a6897467bebc">More...</a><br/></td></tr>
<tr class="separator:a0a0053b515e25f366a29a6897467bebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a4b602aa7e2656a647323da1bacf50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a38a4b602aa7e2656a647323da1bacf50">lost</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;)</td></tr>
<tr class="memdesc:a38a4b602aa7e2656a647323da1bacf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when a linked process can no longer be monitored.  <a href="#a38a4b602aa7e2656a647323da1bacf50">More...</a><br/></td></tr>
<tr class="separator:a38a4b602aa7e2656a647323da1bacf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed793fe2dc33ea0567836fcccc30c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a4ed793fe2dc33ea0567836fcccc30c6d">inject</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;from, const std::string &amp;name, const char *data=nullptr, size_t length=0)</td></tr>
<tr class="memdesc:a4ed793fe2dc33ea0567836fcccc30c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the message at front of this process's message queue.  <a href="#a4ed793fe2dc33ea0567836fcccc30c6d">More...</a><br/></td></tr>
<tr class="separator:a4ed793fe2dc33ea0567836fcccc30c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d581940120abfb787e46568e7a3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#af90d581940120abfb787e46568e7a3af">send</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;to, const std::string &amp;name, const char *data=nullptr, size_t length=0)</td></tr>
<tr class="memdesc:af90d581940120abfb787e46568e7a3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the message to the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#af90d581940120abfb787e46568e7a3af">More...</a><br/></td></tr>
<tr class="separator:af90d581940120abfb787e46568e7a3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97b59a857843096aa219d0209837c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess_1_1UPID.html">UPID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42">link</a> (const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;pid, const <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a> remote=<a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a>)</td></tr>
<tr class="memdesc:ae97b59a857843096aa219d0209837c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links with the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#ae97b59a857843096aa219d0209837c42">More...</a><br/></td></tr>
<tr class="separator:ae97b59a857843096aa219d0209837c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591501723f8320f0b29e2a7c64a501eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a591501723f8320f0b29e2a7c64a501eb">install</a> (const std::string &amp;name, const <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a591501723f8320f0b29e2a7c64a501eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for messages with the specified name.  <a href="#a591501723f8320f0b29e2a7c64a501eb">More...</a><br/></td></tr>
<tr class="separator:a591501723f8320f0b29e2a7c64a501eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfef5689de05716f582fa737f165133"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dfef5689de05716f582fa737f165133"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a8dfef5689de05716f582fa737f165133">install</a> (const std::string &amp;name, void(T::*method)(const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;))</td></tr>
<tr class="memdesc:a8dfef5689de05716f582fa737f165133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for messages with the specified name.  <a href="#a8dfef5689de05716f582fa737f165133">More...</a><br/></td></tr>
<tr class="separator:a8dfef5689de05716f582fa737f165133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685d23d0dc0f42a0038dda0724e5d783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a685d23d0dc0f42a0038dda0724e5d783">delegate</a> (const std::string &amp;name, const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;pid)</td></tr>
<tr class="memdesc:a685d23d0dc0f42a0038dda0724e5d783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates incoming messages, with the specified name, to the <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>.  <a href="#a685d23d0dc0f42a0038dda0724e5d783">More...</a><br/></td></tr>
<tr class="separator:a685d23d0dc0f42a0038dda0724e5d783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5">route</a> (const std::string &amp;name, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, const <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a> &amp;handler, const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for HTTP requests with the specified name.  <a href="#af0d1a6f8da798dfb2b6ea92550b8c6f5">More...</a><br/></td></tr>
<tr class="separator:af0d1a6f8da798dfb2b6ea92550b8c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff038897726b5ff2713e5d5602efa6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70ff038897726b5ff2713e5d5602efa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a70ff038897726b5ff2713e5d5602efa6">route</a> (const std::string &amp;name, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*method)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;), const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:a70ff038897726b5ff2713e5d5602efa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for HTTP requests with the specified name.  <a href="#a70ff038897726b5ff2713e5d5602efa6">More...</a><br/></td></tr>
<tr class="separator:a70ff038897726b5ff2713e5d5602efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb721f72a1b9b517808149010de8b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a0bb721f72a1b9b517808149010de8b9a">route</a> (const std::string &amp;name, const std::string &amp;realm, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, const <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a> &amp;handler, const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="separator:a0bb721f72a1b9b517808149010de8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897bf0b650b9fc56fc87fd005827c8ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a897bf0b650b9fc56fc87fd005827c8ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a897bf0b650b9fc56fc87fd005827c8ce">route</a> (const std::string &amp;name, const std::string &amp;realm, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;help, <a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*method)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;), const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;options=<a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>())</td></tr>
<tr class="memdesc:a897bf0b650b9fc56fc87fd005827c8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a handler for HTTP requests with the specified name.  <a href="#a897bf0b650b9fc56fc87fd005827c8ce">More...</a><br/></td></tr>
<tr class="separator:a897bf0b650b9fc56fc87fd005827c8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b32f94df3a92225825a1cc426b060c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a6b32f94df3a92225825a1cc426b060c8">provide</a> (const std::string &amp;name, const std::string &amp;path, const std::map&lt; std::string, std::string &gt; &amp;types=<a class="el" href="namespaceprocess_1_1mime.html#aa12bd84b9c99ba313fbbf8c56bc411cb">mime::types</a>)</td></tr>
<tr class="memdesc:a6b32f94df3a92225825a1cc426b060c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the default HTTP request handler to provide the static asset(s) at the specified <em>absolute</em> path for the specified name.  <a href="#a6b32f94df3a92225825a1cc426b060c8">More...</a><br/></td></tr>
<tr class="separator:a6b32f94df3a92225825a1cc426b060c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641dc674baabe6a58e4f4869090bd310"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a641dc674baabe6a58e4f4869090bd310"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a641dc674baabe6a58e4f4869090bd310">eventCount</a> ()</td></tr>
<tr class="memdesc:a641dc674baabe6a58e4f4869090bd310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of events of the given type currently on the event queue.  <a href="#a641dc674baabe6a58e4f4869090bd310">More...</a><br/></td></tr>
<tr class="separator:a641dc674baabe6a58e4f4869090bd310"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a43e117b196c850619d5255046edb3e79"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#a43e117b196c850619d5255046edb3e79">SocketManager</a></td></tr>
<tr class="separator:a43e117b196c850619d5255046edb3e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1701c7594fe2cf1c96b951a52eb0396"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#ae1701c7594fe2cf1c96b951a52eb0396">ProcessManager</a></td></tr>
<tr class="separator:ae1701c7594fe2cf1c96b951a52eb0396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa743cee5ab8213f9d59a8d4fe190f45b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#aa743cee5ab8213f9d59a8d4fe190f45b">ProcessReference</a></td></tr>
<tr class="separator:aa743cee5ab8213f9d59a8d4fe190f45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2e3480d3fd92960e1addaf8cc71d6b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprocess_1_1ProcessBase.html#adf2e3480d3fd92960e1addaf8cc71d6b">schedule</a> (void *)</td></tr>
<tr class="separator:adf2e3480d3fd92960e1addaf8cc71d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0834b08377ce20a01893a033c46898f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;<a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a>&gt; const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp;, const <a class="el" href="classOption.html">Option</a>&lt;<a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a>&gt;&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">process::ProcessBase::AuthenticatedHttpRequestHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and an <code><a class="el" href="classOption.html">Option</a>&lt;Principal&gt;</code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>. </p>
<p>This type is meant to be used for the endpoint handlers of authenticated HTTP endpoints.</p>
<p>If the handler is called and the principal is set, this implies two things: 1) The realm that the handler's endpoint is installed into requires authentication. 2) The HTTP request has been successfully authenticated.</p>
<p>If the principal is not set, then the endpoint's realm does not require authentication.</p>
<p>The default visit implementation for HTTP events invokes installed HTTP handlers.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a083d8346a62ad423899f6f9e9ee08806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;<a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a>&gt;const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">process::ProcessBase::HttpRequestHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a <code><a class="el" href="structprocess_1_1http_1_1Request.html">process::http::Request</a></code> and returns a <code><a class="el" href="structprocess_1_1http_1_1Response.html">process::http::Response</a></code>. </p>
<p>The default visit implementation for HTTP events invokes installed HTTP handlers.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#af0d1a6f8da798dfb2b6ea92550b8c6f5" title="Sets up a handler for HTTP requests with the specified name. ">process::ProcessBase::route</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7ca53e513d7ead18e05466c60e51891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef lambda::function&lt;void(const <a class="el" href="structprocess_1_1UPID.html">UPID</a>&amp;, const std::string&amp;)&gt; <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">process::ProcessBase::MessageHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any function which takes a "from" <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code> and a message body as arguments. </p>
<p>The default visit implementation for message events invokes installed message handlers, or delegates the message to another process. A message handler always takes precedence over delegating.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#a591501723f8320f0b29e2a7c64a501eb" title="Sets up a handler for messages with the specified name. ">process::ProcessBase::install</a> </dd>
<dd>
<a class="el" href="classprocess_1_1ProcessBase.html#a685d23d0dc0f42a0038dda0724e5d783" title="Delegates incoming messages, with the specified name, to the UPID. ">process::ProcessBase::delegate</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">process::ProcessBase::RemoteConnection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the behavior of the <code>link</code> call when the target <code>pid</code> points to a remote process. </p>
<p>This enum has no effect if the target <code>pid</code> points to a local process. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e"></a>REUSE</em>&nbsp;</td><td class="fielddoc">
<p>If a persistent socket to the target <code>pid</code> does not exist, a new link is created. </p>
<p>If a persistent socket already exists, <code>link</code> will subscribe this process to the existing link.</p>
<p>This is the default behavior. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a39f8e327dc132dd4a3a95fee650458f8a435d743b35551ea7106af41c4a308c01"></a>RECONNECT</em>&nbsp;</td><td class="fielddoc">
<p>If a persistent socket to the target <code>pid</code> does not exist, a new link is created. </p>
<p>If a persistent socket already exists, <code>link</code> create a new socket connection with the target <code>pid</code> and <em>atomically</em> swap the existing link with the new link.</p>
<p>Existing linkers will remain linked, albeit via the new socket. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a318038bacd95e4260864533f7cfe12fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">process::ProcessBase::ProcessBase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20b6c6b8f5aff506a97ce6c4f91a29d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual process::ProcessBase::~ProcessBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a685d23d0dc0f42a0038dda0724e5d783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::delegate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delegates incoming messages, with the specified name, to the <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>

</div>
</div>
<a class="anchor" id="a641dc674baabe6a58e4f4869090bd310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t process::ProcessBase::eventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of events of the given type currently on the event queue. </p>

</div>
</div>
<a class="anchor" id="a0a0053b515e25f366a29a6897467bebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::exited </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a linked process has exited. </p>
<p>For local linked processes (i.e., when the linker and linkee are part of the same OS process), this can be used to reliably detect when the linked process has exited.</p>
<p>For remote linked processes, this indicates that the persistent TCP connection between the linker and the linkee has failed (e.g., linkee process died, a network error occurred). In this situation, the remote linkee process might still be running.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42" title="Links with the specified UPID. ">process::ProcessBase::link</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#ab84125e8b6ac8adadadd40df0e63920f">mesos::internal::master::Master</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#afc9437a65ba512cdfa4cd082b0e95d55">mesos::internal::slave::Slave</a>, and <a class="el" href="classprocess_1_1GarbageCollector.html#a0de78001ba179347eceaff5136a71ee4">process::GarbageCollector</a>.</p>

</div>
</div>
<a class="anchor" id="a07ac3fd4eededbb6015c305e12411b98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a process is terminated. </p>
<p><b>NOTE</b>: this does not get invoked automatically if <code><a class="el" href="classprocess_1_1ProcessBase.html#a34a0d883ad4159e8780e6e1698a7c00a">process::ProcessBase::visit(const TerminateEvent&amp;)</a></code> is overridden. </p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#aadfa2612b8297613788ed47d1e0ba817">mesos::internal::master::Master</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#ac81938c4eeee7234af198a86c13911fc">mesos::internal::slave::Slave</a>, <a class="el" href="classNetworkProcess.html#a36b7e3c3759a96959823ee339fa68392">NetworkProcess</a>, <a class="el" href="classmesos_1_1internal_1_1recordio_1_1internal_1_1ReaderProcess.html#a591bf74929a5fc7db08c73c1761e7a50">mesos::internal::recordio::internal::ReaderProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogWriterProcess.html#ae90aff3b3439fb99379296db1ebff980">mesos::internal::log::LogWriterProcess</a>, <a class="el" href="classprocess_1_1SequenceProcess.html#a6eae0ed53077a4573c73d0a36ed7964d">process::SequenceProcess</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogReaderProcess.html#a7b1d0d66aee598f4a19c0b38010b5e42">mesos::internal::log::LogReaderProcess</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1CgroupsIsolatorProcess.html#a28cc5ac3d37ed6a87db5c538c56bcb13">mesos::internal::slave::CgroupsIsolatorProcess</a>, <a class="el" href="classprocess_1_1RateLimiterProcess.html#a52f385d91c5420d62baef6c6054b408a">process::RateLimiterProcess</a>, <a class="el" href="classprocess_1_1System.html#ac64aa6bb6638963782932ebfc140c952">process::System</a>, and <a class="el" href="classmesos_1_1internal_1_1log_1_1LogProcess.html#ac9a5bbcfa324d5ef3abb72b2a307592d">mesos::internal::log::LogProcess</a>.</p>

</div>
</div>
<a class="anchor" id="a6baf49d6234eb638d068a98514e4ae3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a process gets spawned. </p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Heartbeater.html#a4585413d38780721afc39a80653f13b5">mesos::internal::master::Heartbeater</a>, <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#ae3b5c560a4dc2a611f3b11b1642d9623">mesos::internal::master::Master</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1Slave.html#ace99b8066d4aed8f21395f025118fc10">mesos::internal::slave::Slave</a>, <a class="el" href="classmesos_1_1internal_1_1recordio_1_1internal_1_1ReaderProcess.html#af123bea3321a9d99d1fecaf33cd5179b">mesos::internal::recordio::internal::ReaderProcess&lt; T &gt;</a>, <a class="el" href="classzookeeper_1_1GroupProcess.html#a2bd94b2043dc0f484858eae235333439">zookeeper::GroupProcess</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogWriterProcess.html#a4896aaab8e6d04562965ea678034543e">mesos::internal::log::LogWriterProcess</a>, <a class="el" href="classprocess_1_1internal_1_1AwaitProcess.html#a8121fadd91f2221a673d4e711f22c948">process::internal::AwaitProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1checks_1_1HealthCheckerProcess.html#a0f884374cd8b77fb5d36bdde09222f77">mesos::internal::checks::HealthCheckerProcess</a>, <a class="el" href="classprocess_1_1Help.html#ab60e978a150594aae173311d776483c5">process::Help</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogReaderProcess.html#a7af658bc98f66d4ca187e02bfa303c6d">mesos::internal::log::LogReaderProcess</a>, <a class="el" href="classmesos_1_1internal_1_1tests_1_1MockSlave.html#af9cfa726c89c0d1dc9a64be3e87c6b12">mesos::internal::tests::MockSlave</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1CgroupsIsolatorProcess.html#af15917f9898bb6d74495dc163ea19ec1">mesos::internal::slave::CgroupsIsolatorProcess</a>, <a class="el" href="classprocess_1_1internal_1_1CollectProcess.html#a6e13d430bd37e93903d3f0b4201b8e31">process::internal::CollectProcess&lt; T &gt;</a>, <a class="el" href="classmesos_1_1internal_1_1slave_1_1PerfEventSubsystem.html#a624c2b34dabb1615433c70fa03a04a0f">mesos::internal::slave::PerfEventSubsystem</a>, <a class="el" href="classmesos_1_1internal_1_1log_1_1LogProcess.html#ada6f3c8f17d59a9d78071542a02e6f7d">mesos::internal::log::LogProcess</a>, <a class="el" href="classmesos_1_1internal_1_1VersionProcess.html#a1f0746cf6e384fc26bfd7e892fa464c2">mesos::internal::VersionProcess</a>, <a class="el" href="classmesos_1_1internal_1_1WhitelistWatcher.html#a554e828d1e5aa7a84c5b38ad20a7731f">mesos::internal::WhitelistWatcher</a>, <a class="el" href="classprocess_1_1System.html#a5cfa4acb240377af06c74eca269df423">process::System</a>, <a class="el" href="classprocess_1_1metrics_1_1internal_1_1MetricsProcess.html#a481de823013045447009d4554fdaf69d">process::metrics::internal::MetricsProcess</a>, <a class="el" href="classprocess_1_1Logging.html#aadc2611836b2e3e9f6ea667e06da4fa5">process::Logging</a>, <a class="el" href="classprocess_1_1internal_1_1ReaperProcess.html#afeb3d27d616c3c7c3b63f22eb0828dbf">process::internal::ReaperProcess</a>, and <a class="el" href="classprocess_1_1Profiler.html#a9131797d93999031d9e732c8a2d45da4">process::Profiler</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed793fe2dc33ea0567836fcccc30c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::inject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the message at front of this process's message queue. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structprocess_1_1Message.html">process::Message</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a591501723f8320f0b29e2a7c64a501eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::install </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for messages with the specified name. </p>

</div>
</div>
<a class="anchor" id="a8dfef5689de05716f582fa737f165133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::install </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;, const std::string &amp;)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for messages with the specified name. </p>

</div>
</div>
<a class="anchor" id="ae97b59a857843096aa219d0209837c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_1_1UPID.html">UPID</a> process::ProcessBase::link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8">RemoteConnection</a>&#160;</td>
          <td class="paramname"><em>remote</em> = <code><a class="el" href="classprocess_1_1ProcessBase.html#a39f8e327dc132dd4a3a95fee650458f8a0a8e4fd54250dc259c749ebf914f6a5e">RemoteConnection::REUSE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links with the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>
<p>Linking with a process from within the same OS process is guaranteed to give you perfect monitoring of that process.</p>
<p>Linking to a remote process establishes a persistent TCP connection to the remote libprocess instance that hosts that process. If the TCP connection fails, the true state of the remote linked process cannot be determined; we handle this situation by generating an <a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a>. </p>

</div>
</div>
<a class="anchor" id="a38a4b602aa7e2656a647323da1bacf50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::lost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when a linked process can no longer be monitored. </p>
<p>TODO(neilc): This is not implemented.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classprocess_1_1ProcessBase.html#ae97b59a857843096aa219d0209837c42" title="Links with the specified UPID. ">process::ProcessBase::link</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b32f94df3a92225825a1cc426b060c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::provide </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em> = <code><a class="el" href="namespaceprocess_1_1mime.html#aa12bd84b9c99ba313fbbf8c56bc411cb">mime::types</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up the default HTTP request handler to provide the static asset(s) at the specified <em>absolute</em> path for the specified name. </p>
<p>For example, assuming the process named "server" invoked <code>provide("name", "path")</code>, then an HTTP request for <code>/server/name</code> would return the asset found at "path". If the specified path is a directory then an HTTP request for <code>/server/name/file</code> would return the asset found at <code>/path/file</code>.</p>
<p>The <code>Content-Type</code> header of the HTTP response will be set to the specified type given the file extension, which can be changed via the optional <code>types</code> parameter. </p>

</div>
</div>
<a class="anchor" id="af0d1a6f8da798dfb2b6ea92550b8c6f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a083d8346a62ad423899f6f9e9ee08806">HttpRequestHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for HTTP requests with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The endpoint or URL to route. Must begin with a <code>/</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70ff038897726b5ff2713e5d5602efa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for HTTP requests with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The endpoint or URL to route. Must begin with a <code>/</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bb721f72a1b9b517808149010de8b9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprocess_1_1ProcessBase.html#a0834b08377ce20a01893a033c46898f6">AuthenticatedHttpRequestHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a897bf0b650b9fc56fc87fd005827c8ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::route </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>help</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structprocess_1_1http_1_1Response.html">http::Response</a> &gt;(T::*)(const <a class="el" href="structprocess_1_1http_1_1Request.html">http::Request</a> &amp;, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structprocess_1_1http_1_1authentication_1_1Principal.html">http::authentication::Principal</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structprocess_1_1ProcessBase_1_1RouteOptions.html">RouteOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a handler for HTTP requests with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The endpoint or URL to route. Must begin with a <code>/</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc5a9a47e9c36edb42e03bfb6adfee65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess_1_1UPID.html">UPID</a> process::ProcessBase::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af90d581940120abfb787e46568e7a3af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process::ProcessBase::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1UPID.html">UPID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the message to the specified <code><a class="el" href="structprocess_1_1UPID.html" title="An &quot;untyped&quot; PID, used to encapsulate the process ID for lower-layer abstractions (eg...">UPID</a></code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structprocess_1_1Message.html">process::Message</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a79814ca5804d56a805d43bc1c86ee1e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::serve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1Event.html">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when an event is serviced. </p>

<p>Reimplemented in <a class="el" href="classprocess_1_1internal_1_1ThunkProcess.html#a97044a7116c1d0b5dd966908444a0419">process::internal::ThunkProcess&lt; R &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afada1b4232e2867717bc3cf6d296e2b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1MessageEvent.html">MessageEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventVisitor.html#a2c6446217ce0718ea9c7b87e2ca93049">process::EventVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#abc98aab1998bf1a0db65bd0a6799bc9c">mesos::internal::master::Master</a>, <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; T &gt;</a>, <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; Slave &gt;</a>, <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; NetworkProcess &gt;</a>, <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; Master &gt;</a>, <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; HealthCheckerProcess &gt;</a>, and <a class="el" href="classProtobufProcess.html#a815baf04a27f8675a1a92a6c1075d969">ProtobufProcess&lt; ReqResProcess&lt; Req, Res &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9b7eb1f7b22934a2ae9787ec4129b879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1DispatchEvent.html">DispatchEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventVisitor.html#ac5a1087909568bbac1213d32105e1221">process::EventVisitor</a>.</p>

</div>
</div>
<a class="anchor" id="a6c225bbf6d2fd8f93e827ef3515a7e20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1HttpEvent.html">HttpEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventVisitor.html#a262d352ed7de8dcb9bfed7d8ce0d450e">process::EventVisitor</a>.</p>

</div>
</div>
<a class="anchor" id="a394f43bc1b3a1d1e1f9ea67772040902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1ExitedEvent.html">ExitedEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventVisitor.html#a699f0cd053139bdcee787f51194bbc5e">process::EventVisitor</a>.</p>

<p>Reimplemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1Master.html#ac6025245facc481ba42f7208969494df">mesos::internal::master::Master</a>.</p>

</div>
</div>
<a class="anchor" id="a34a0d883ad4159e8780e6e1698a7c00a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process::ProcessBase::visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structprocess_1_1TerminateEvent.html">TerminateEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structprocess_1_1EventVisitor.html#a73ab5ec3df4760a4f66c226d3760e696">process::EventVisitor</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae1701c7594fe2cf1c96b951a52eb0396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ProcessManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa743cee5ab8213f9d59a8d4fe190f45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classprocess_1_1ProcessReference.html">ProcessReference</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf2e3480d3fd92960e1addaf8cc71d6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* schedule </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43e117b196c850619d5255046edb3e79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SocketManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a120889e50b21c8b76f5f3301d498d8e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, HttpEndpoint&gt; process::ProcessBase::http</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55a5326c3f9b66bc56cc13c7bf4c350d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Owned.html">Owned</a>&lt;<a class="el" href="classprocess_1_1Sequence.html">Sequence</a>&gt; process::ProcessBase::httpSequence</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a025e342d8f2be6c42fe34031edda54a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classprocess_1_1ProcessBase.html#ab7ca53e513d7ead18e05466c60e51891">MessageHandler</a>&gt; process::ProcessBase::message</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>3rdparty/libprocess/include/process/<a class="el" href="libprocess_2include_2process_2process_8hpp_source.html">process.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
